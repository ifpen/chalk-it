{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Welcome to Chalk'it. Chalk'it ambition is to allow technicians, scientists or engineers, not specialists in web technologies, to build their own web applications based on the Python code, JavaScript code or web-services they develop. For your first steps, follow the Quickstart tutorial.","title":"Welcome"},{"location":"#welcome","text":"Welcome to Chalk'it. Chalk'it ambition is to allow technicians, scientists or engineers, not specialists in web technologies, to build their own web applications based on the Python code, JavaScript code or web-services they develop. For your first steps, follow the Quickstart tutorial.","title":"Welcome"},{"location":"basics/","text":"Chalk'it features a synchronous/reactive real-time and multi-rhythm execution engine, which is the \u201cleader orchestra\u201d of the execution of calculations and interactions. It also features an intuitive designer dashboards by simple drag&drop. The development of a web-application with Chalk'it is based on the following concepts: Workspace: Concept analogous to the workspace of Matlab or IPython. It contains JSON or Python objects that have a given state and are accessible to other tool entities. DataNode: Concept analogous to a cell of a Notebook Jupyter. It can be seen as a function which should produce a JSON result or a Python object (only for the Pyodide dataNode). DataNodes can also have an execution period. \u201cdataNodes\u201d keyword: Concept for creating a dataflow between dataNodes (aka nodes). It is used inside a script-like DataNode to express a data and execution dependency with a predecessor node. Execution graph: Dependency relationships defined by the \u201cdataNodes\u201d keyword that organize the application logic. User actions on widgets trigger the execution of the concerned dataflow. Widget: Graphic object defined by a rectangle in the HTML page for User interface. It interacts with the workspace via connection points called actuators. Actions are as diverse as clicking a button, entering text or numeric values, scrolling cursors, selecting items from drop-down lists. Widgets allow complex visualizations thanks to the integrated libraries, such as Plotly.js, Charts, Vega (JavaScript) or Plotly and Matplotlib (both Python). Methods for visualizing data on maps based on Leaflet.js are also added. Connection: Notion defining the link between a widget (via its actuator) and a DataNode. Document: JSON document describing the whole working model including the Chalk'it dashboard. The document has the extension xprjson, and is similar to the ipynb format of Jupyter notebooks. Page: The result of the xprjson document is an HTML page that contains the dashboard. This page is the web application. It can be hosted on a static page server and shared thanks to its link to considerably facilitate exchanges. A Chalk'it page is an HTML file which includes the xprjson document file and its associated JavaScript and CSS runtime libraries.","title":"Basics"},{"location":"chalkitapi/","text":"Chalk'it APIs \u00b6 Chalk'it offers a set of APIs through chalkit that serve two primary purposes: Scheduler APIs: Facilitate the scheduling process by enabling the modification of dataNode variables and launching the scheduler. Dashboard APIs: Support the developpement of multi-dashboard applications. chalkit currently operates with JavaScript-type dataNodes. Scheduler features \u00b6 The main feature allows the setting of dataNode variables in a script, replicating the behavior of a user interacting with a basic input/control widget. The assessment of these functions is handled at the end of the current scheduling instance. setVariable \u00b6 chalkit . setVariable ( dataNodeName , dataNodeValue ); This API sets the value dataNodeValue to the dataNode identified by dataNode[\" dataNodeName \"]. dataNodeName: The name of the dataNode, must be a string. dataNodeValue: The value to be assigned to the dataNode, which can be any JavaScript primitive type (number, string, boolean), array or JSON. For example, if you have a dataNode info_person that contains: { \"name\" : \"John Doe\" , \"age\" : \"30\" } To modify it by another JSON value, you can use the following code: chalkit . setVariable ( \"info_person\" , { \"name\" : \"Jane Doe\" , \"age\" : \"25\" }); setVariableProperty \u00b6 chalkit . setVariableProperty ( dataNodeName , propertyPath , dataNodeValue ); This API allows to modify a specific property within a dataNode (not the entire dataNode). It assigns the value dataNodeValue to the specified property path: dataNode[\" dataNodeName \"]. propertyPath . dataNodeName: The name of the dataNode, must be a string. propertyPath: The path of the dataNode property to be modified, supporting JavaScript primitive types (number, string, boolean), array or JSON. dataNodeValue: The value to be set to the dataNode property, can be of any JavaScript primitive type (number, string, boolean), array or JSON. For example, if you have a dataNode info_address that contains: { \"name\" : \"personal address\" , \"address\" : { \"city\" : \"New York\" , \"details\" : { \"street\" : \"123 Main St\" , \"zipCode\" : \"10001\" , \"country\" : \"USA\" } } } To update the value of the street property in the nested structure within info_address , you can use the following code: chalkit . setVariableProperty ( \"info_person\" , [ \"address\" , \"details\" , \"street\" ], \"West 23rd Street\" ); setVariables \u00b6 chalkit . setVariables ( dataNodeNames , dataNodeValues ); This API sets each value dataNodeValues[i] to dataNode[\" dataNodeNames[i] \"], where i:0 .. length-1 of dataNodeNames . dataNodeNames: An array containing the names of dataNodes, each as a string. dataNodeValues: An array containing the corresponding values for the dataNodes, can be of any JavaScript primitive type (number, string, boolean), array or JSON. This array must match the size of dataNodeNames. For example, to modify at the same time the previous dataNode info_person and another dataNode info_gender that contains: { \"gender\" : \"male\" } you can use the following code: chalkit . setVariables ([ \"info_person\" , \"info_gender\" ], [{ \"name\" : \"Jane Doe\" , \"age\" : \"25\" },{ \"gender\" : \"female\" }]); executeDataNode \u00b6 chalkit . executeDataNode ( dataNodeName ); This API allows to launch the schedule with the source node identified as dataNodeName (the name of the dataNode that must be a string). This functionality can be useful for a dataNode with explicit trigger flag set to true. Its execution can be explicitly triggered by this API, in addition to being triggered by an associated push button widget or by clicking on the dataNode update icon present in the dataNodes list. executeDataNodes \u00b6 chalkit . executeDataNodes ( dataNodeNames ); This API is similar to executeDataNode , except it launches the schedule with multiple source nodes defined in the dataNodeNames array, where each name is represented as a string. Dashboard features \u00b6 The main feature allow navigation between Chalk'it pages with parameter transfer. When landing at the target page, specified dataNodes of type Variable can have their initial values modified, as described below. goToPage \u00b6 In constrained dashboard mode , the method: chalkit . goToPage ( pageNumber ) allows to show only the targed page. It is the main method for building multi-page app with custom navigation control. viewPage \u00b6 chalkit . viewPage ( pageUrl , inputVals , bNewTab ) Navigates to pageUrl , setting the values of the specified dataNodes in inputVals. pageUrl: target page URL inputVals: an array of structures of type { \"dsName\" : \"dataNodeName\" , \"dsVal\" : \"dataNodeValue\" } dsName should be of type string. dsVal can be of any JavaScript primitive type (number, string, boolean), array or JSON. bNewTab: open in new tab when true. viewProject \u00b6 Similar to view page, but applies for projects. chalkit . viewProject ( projectUrl , inputVals , bNewTab )","title":"Chalk'it APIs"},{"location":"chalkitapi/#chalkit-apis","text":"Chalk'it offers a set of APIs through chalkit that serve two primary purposes: Scheduler APIs: Facilitate the scheduling process by enabling the modification of dataNode variables and launching the scheduler. Dashboard APIs: Support the developpement of multi-dashboard applications. chalkit currently operates with JavaScript-type dataNodes.","title":"Chalk'it APIs"},{"location":"chalkitapi/#scheduler-features","text":"The main feature allows the setting of dataNode variables in a script, replicating the behavior of a user interacting with a basic input/control widget. The assessment of these functions is handled at the end of the current scheduling instance.","title":"Scheduler features"},{"location":"chalkitapi/#setvariable","text":"chalkit . setVariable ( dataNodeName , dataNodeValue ); This API sets the value dataNodeValue to the dataNode identified by dataNode[\" dataNodeName \"]. dataNodeName: The name of the dataNode, must be a string. dataNodeValue: The value to be assigned to the dataNode, which can be any JavaScript primitive type (number, string, boolean), array or JSON. For example, if you have a dataNode info_person that contains: { \"name\" : \"John Doe\" , \"age\" : \"30\" } To modify it by another JSON value, you can use the following code: chalkit . setVariable ( \"info_person\" , { \"name\" : \"Jane Doe\" , \"age\" : \"25\" });","title":"setVariable"},{"location":"chalkitapi/#setvariableproperty","text":"chalkit . setVariableProperty ( dataNodeName , propertyPath , dataNodeValue ); This API allows to modify a specific property within a dataNode (not the entire dataNode). It assigns the value dataNodeValue to the specified property path: dataNode[\" dataNodeName \"]. propertyPath . dataNodeName: The name of the dataNode, must be a string. propertyPath: The path of the dataNode property to be modified, supporting JavaScript primitive types (number, string, boolean), array or JSON. dataNodeValue: The value to be set to the dataNode property, can be of any JavaScript primitive type (number, string, boolean), array or JSON. For example, if you have a dataNode info_address that contains: { \"name\" : \"personal address\" , \"address\" : { \"city\" : \"New York\" , \"details\" : { \"street\" : \"123 Main St\" , \"zipCode\" : \"10001\" , \"country\" : \"USA\" } } } To update the value of the street property in the nested structure within info_address , you can use the following code: chalkit . setVariableProperty ( \"info_person\" , [ \"address\" , \"details\" , \"street\" ], \"West 23rd Street\" );","title":"setVariableProperty"},{"location":"chalkitapi/#setvariables","text":"chalkit . setVariables ( dataNodeNames , dataNodeValues ); This API sets each value dataNodeValues[i] to dataNode[\" dataNodeNames[i] \"], where i:0 .. length-1 of dataNodeNames . dataNodeNames: An array containing the names of dataNodes, each as a string. dataNodeValues: An array containing the corresponding values for the dataNodes, can be of any JavaScript primitive type (number, string, boolean), array or JSON. This array must match the size of dataNodeNames. For example, to modify at the same time the previous dataNode info_person and another dataNode info_gender that contains: { \"gender\" : \"male\" } you can use the following code: chalkit . setVariables ([ \"info_person\" , \"info_gender\" ], [{ \"name\" : \"Jane Doe\" , \"age\" : \"25\" },{ \"gender\" : \"female\" }]);","title":"setVariables"},{"location":"chalkitapi/#executedatanode","text":"chalkit . executeDataNode ( dataNodeName ); This API allows to launch the schedule with the source node identified as dataNodeName (the name of the dataNode that must be a string). This functionality can be useful for a dataNode with explicit trigger flag set to true. Its execution can be explicitly triggered by this API, in addition to being triggered by an associated push button widget or by clicking on the dataNode update icon present in the dataNodes list.","title":"executeDataNode"},{"location":"chalkitapi/#executedatanodes","text":"chalkit . executeDataNodes ( dataNodeNames ); This API is similar to executeDataNode , except it launches the schedule with multiple source nodes defined in the dataNodeNames array, where each name is represented as a string.","title":"executeDataNodes"},{"location":"chalkitapi/#dashboard-features","text":"The main feature allow navigation between Chalk'it pages with parameter transfer. When landing at the target page, specified dataNodes of type Variable can have their initial values modified, as described below.","title":"Dashboard features"},{"location":"chalkitapi/#gotopage","text":"In constrained dashboard mode , the method: chalkit . goToPage ( pageNumber ) allows to show only the targed page. It is the main method for building multi-page app with custom navigation control.","title":"goToPage"},{"location":"chalkitapi/#viewpage","text":"chalkit . viewPage ( pageUrl , inputVals , bNewTab ) Navigates to pageUrl , setting the values of the specified dataNodes in inputVals. pageUrl: target page URL inputVals: an array of structures of type { \"dsName\" : \"dataNodeName\" , \"dsVal\" : \"dataNodeValue\" } dsName should be of type string. dsVal can be of any JavaScript primitive type (number, string, boolean), array or JSON. bNewTab: open in new tab when true.","title":"viewPage"},{"location":"chalkitapi/#viewproject","text":"Similar to view page, but applies for projects. chalkit . viewProject ( projectUrl , inputVals , bNewTab )","title":"viewProject"},{"location":"recipes/","text":"Some useful recipes \u00b6 JavaScript recipes \u00b6 Simple key/value JSON to table (linewise) \u00b6 return [ _ . keys ( dataNodes [ \"vehicle\" ]), _ . values ( dataNodes [ \"vehicle\" ])]; See json-to-table-linewise-js.xprjson Simple key/value JSON to table (columnwise) \u00b6 return _ . unzip ([ _ . keys ( dataNodes [ \"vehicle\" ]), _ . values ( dataNodes [ \"vehicle\" ])]); See json-to-table-columnwise-js.xprjson Read CSV, display content and write it to file \u00b6 See csv-read-write-js.xprjson Plotly \u00b6 x-axis with time \u00b6 See plotly-with-date-time-js.xprjson Read xlsx file from URL and convert it to JSON \u00b6 See xls-from-url-to-json-js.xprjson","title":"Recipes"},{"location":"recipes/#some-useful-recipes","text":"","title":"Some useful recipes"},{"location":"recipes/#javascript-recipes","text":"","title":"JavaScript recipes"},{"location":"recipes/#simple-keyvalue-json-to-table-linewise","text":"return [ _ . keys ( dataNodes [ \"vehicle\" ]), _ . values ( dataNodes [ \"vehicle\" ])]; See json-to-table-linewise-js.xprjson","title":"Simple key/value JSON to table (linewise)"},{"location":"recipes/#simple-keyvalue-json-to-table-columnwise","text":"return _ . unzip ([ _ . keys ( dataNodes [ \"vehicle\" ]), _ . values ( dataNodes [ \"vehicle\" ])]); See json-to-table-columnwise-js.xprjson","title":"Simple key/value JSON to table (columnwise)"},{"location":"recipes/#read-csv-display-content-and-write-it-to-file","text":"See csv-read-write-js.xprjson","title":"Read CSV, display content and write it to file"},{"location":"recipes/#plotly","text":"","title":"Plotly"},{"location":"recipes/#x-axis-with-time","text":"See plotly-with-date-time-js.xprjson","title":"x-axis with time"},{"location":"recipes/#read-xlsx-file-from-url-and-convert-it-to-json","text":"See xls-from-url-to-json-js.xprjson","title":"Read xlsx file from URL and convert it to JSON"},{"location":"ds/ds-basics/","text":"Basics \u00b6 Variable \u00b6 Variable is the cornerstone of Chalk'it. With the Variable dataNode type, a JSON, an array or a primitive variable can be manually defined or read from file. A variable is readable and writable : its value can be modified by a widget . This makes Chalk'it different from other tools that only perform data visualization. The user can import a JSON variable from a file, export it to a file, or manually edit the parameters using the tree editor located in the lower portion of its edition panel. Simple example : simple-json.xprjson Scripts \u00b6 Script-type dataNode is used to write specific Python or JavaScript code that will be executed on the client side. It may use the output of the other dataNodes (referenced using keyword dataNodes ). Currently, there types of Script dataNodes exist in Chalk'it : Python Script (Pyodide) JavaScript Script (client-side) Below is a screenshot of a Python Script (Pyodide) edition panel : In this example, dataNode multiply references the dataNode input , specifically its property named value . This is specified using the keywords dataNodes[\"input\"][\"value\"] . A final return statement is required to return the result of the Script evaluation to Chalk'it workspace. Complete example : py-script.xprjson The code is executed according to Chalk'it runtime rules . Sequencing \u00b6 Chalk'it keeps track of a global dependency graph (a Direct Acyclic Graph). This graph specifies both data and execution dependencies between dataNodes. When a dataNode output changes, all dependent (i.e. subsequent) dataNodes are automatically re-executed. A click on the Script dataNode graph icon displays the dependency graph for the formula dataNode. A click on the graph icon display the complete project graph as shown in the picture below. This dependency graph above describes the relationships of the dataNodes input and multiply above.","title":"Basics"},{"location":"ds/ds-basics/#basics","text":"","title":"Basics"},{"location":"ds/ds-basics/#variable","text":"Variable is the cornerstone of Chalk'it. With the Variable dataNode type, a JSON, an array or a primitive variable can be manually defined or read from file. A variable is readable and writable : its value can be modified by a widget . This makes Chalk'it different from other tools that only perform data visualization. The user can import a JSON variable from a file, export it to a file, or manually edit the parameters using the tree editor located in the lower portion of its edition panel. Simple example : simple-json.xprjson","title":"Variable"},{"location":"ds/ds-basics/#scripts","text":"Script-type dataNode is used to write specific Python or JavaScript code that will be executed on the client side. It may use the output of the other dataNodes (referenced using keyword dataNodes ). Currently, there types of Script dataNodes exist in Chalk'it : Python Script (Pyodide) JavaScript Script (client-side) Below is a screenshot of a Python Script (Pyodide) edition panel : In this example, dataNode multiply references the dataNode input , specifically its property named value . This is specified using the keywords dataNodes[\"input\"][\"value\"] . A final return statement is required to return the result of the Script evaluation to Chalk'it workspace. Complete example : py-script.xprjson The code is executed according to Chalk'it runtime rules .","title":"Scripts"},{"location":"ds/ds-basics/#sequencing","text":"Chalk'it keeps track of a global dependency graph (a Direct Acyclic Graph). This graph specifies both data and execution dependencies between dataNodes. When a dataNode output changes, all dependent (i.e. subsequent) dataNodes are automatically re-executed. A click on the Script dataNode graph icon displays the dependency graph for the formula dataNode. A click on the graph icon display the complete project graph as shown in the picture below. This dependency graph above describes the relationships of the dataNodes input and multiply above.","title":"Sequencing"},{"location":"ds/ds-execution-engine/","text":"Execution engine \u00b6 Chalk'it execution engine implements a synchronous/reactive scheduling algorithm. DataNode instances are the nodes of a direct acyclic graph where edges are data dependencies. They each own a status describing their latest execution state. Last update time indicates the time of the last successful execution. DataNodes status \u00b6 May have one of the following values : None : execution of the dataNode has not happened yet. Pending : execution of the dataNode is pending. This happens when a web-service call takes some time to complete. OK : last execution of the dataNode has completed sucessfully. Error : last execution has completed with error. Execution rules \u00b6 DataNode is executed if and only if all its predecessors completed their execution with an OK status. Every time a dataNode is succesfully computed (status \"OK\"), it triggers the execution of all its successors. Graph execution is interrupted at dataNodes with an Error status. Their successors are not executed. Scheduling instance \u00b6 At first start, graph is scheduled in a breadth-first order starting from source nodes. This is the first schedule instance. Some dataNodes might be updated through different ways : widget value written to dataNode, file imported into dataNode, formula modification, user refresh of dataNode, periodic behavior , chalkit scheduler API ... Such update launches the execution of the corresponding dataNode and a new scheduling instance. Execution flow control parameters \u00b6 The graph execution is controlled by the execution flow control parameters specified in dataNodes. Auto Start \u00b6 When set to false , the associated dataNode is not executed on first execution of the dashboard nor in subsequent ones. Otherwise, i.e. when set to true , default dataNodes execution behavior applies: all nodes are executed by the Chalk'it runtime when all their predecessors successfully completed. For example, Auto Start can be set to false to avoid executing a heavy computation web-service at project load. Default value is true. Sample Time \u00b6 When different from 0, the dataNode is executed every sample time . It's useful for ensuring a periodic real-time execution behavior. Every time a non null sample time is defined, the execution engine computes the greatest common divisor and use it as a its base timer. Sample time is expressed in seconds and must be a multiple of 0.1s. Default value is 0. Explicit Trigger \u00b6 When set to true , the dataNode, in terms of execution flow control, is considered as a source node. It is no longer executed when a direct predecessor is updated. With this setting, it is only executed when it is explicitly triggered by an associated push button widget, by chalkit scheduler APIs , or by a click on the dataNode refresh icon present in the dataNodes list of tabs 1 or 3. Please refer to the Triggered POST example above. Otherwise (i.e. when set to false ), default dataNodes execution behavior applies. Useful for implementing a form-like behavior (setting independently all required dataNode inputs, without executing it with each update, then explicitly triggering its execution). Default value is false. When a direct predecessor is updated, the dataNode, with an Explicit Trigger set to true and a previous succesfull computation (status \"OK\" ), triggers the execution of all its successors. Execution flow control parameters : summary \u00b6 The table below summarizes the execution flow control parameters for the currently available dataNode types in Chalk'it. The checkbox in the table indicates that the property can be customized by the user (true or false). Otherwise, they have the default value indicated above. Type Auto Start Sample Time Explicit Trigger Variable Python Script (Pyodide) JavaScript Script (client-side) REST web-service Generic text file reader Generic binary file reader CSV file reader CSV file player Unzip file Geolocation Clock Delay Memory MQTT WebSocket receive WebSocket send Depending on the execution flow control parameters and the the data flow dependency, the dataNode execution is summarized in the following tables: For nonperiodic dataNodes (Sample Time == 0) Cases Auto Start Explicit Trigger Run at project load Run after predecessor update Run after a user trigger* 1# False False No Yes Yes 2# True False Yes Yes Yes 3# False True No No Yes 4# True True Yes No (last value) Yes *By an associated push button widget, by a click on the dataNode update icon , or by using executeDataNode API . For periodic dataNodes (Sample Time > 0) | Cases | Auto Start | Explicit Trigger | Run at project load | Run after predecessor update | Run after a user trigger* | | :----------------: | :----------------: | :----------------: | :----------------: | :----------------: | :----------------: | | 5# | False | False | No | Yes | Yes | | 6# | True | False | Yes | Yes | Yes | | 7# | False | True | No | No | Yes | | 8# | True | True | Yes | No (last value) | Yes | **For cases 7# and 8#, when the user explicitly triggers the periodic dataNode, the Explicit Trigger option is turned to False . DataNodes capabilities \u00b6 In addition to execution flow control parameters, dataNodes may have common capabilites depending on their type. setInput with formula \u00b6 Python or JavaScript code can be written to define input to dataNode computation. setValue from widget \u00b6 Currently only Variable and Memory dataNodes have this property. It indicates that their workspace value can be modified by widgets that have write capabilities (such as sliders ( horizontal slider ...), value , editable table ...). setValue from file \u00b6 The value of the dataNode can be assigned from a file. See example in Push button . setValue from script \u00b6 Python or JavaScript code can be written to define input to Variable and Memory dataNodes, using chalkit API functions: setVariable setVariableProperty setVariables This is useful to init and reset variables. See example reset-counter.xprjson . The assessment of these functions is handled at the end of the current scheduling instance. DataNodes capabilities : summary \u00b6 The table below summarizes currently available dataNodes in Chalk'it, as well as their major properties in terms of execution flow and data flow . Type setInput with formula setValue from widget setValue from file setValue from script Variable Python Script (Pyodide) JavaScript Script (client-side) REST web-service Generic text file reader Generic binary file reader CSV file reader CSV file player Unzip file Geolocation Clock Delay Memory MQTT WebSocket receive WebSocket send","title":"Execution engine"},{"location":"ds/ds-execution-engine/#execution-engine","text":"Chalk'it execution engine implements a synchronous/reactive scheduling algorithm. DataNode instances are the nodes of a direct acyclic graph where edges are data dependencies. They each own a status describing their latest execution state. Last update time indicates the time of the last successful execution.","title":"Execution engine"},{"location":"ds/ds-execution-engine/#datanodes-status","text":"May have one of the following values : None : execution of the dataNode has not happened yet. Pending : execution of the dataNode is pending. This happens when a web-service call takes some time to complete. OK : last execution of the dataNode has completed sucessfully. Error : last execution has completed with error.","title":"DataNodes status"},{"location":"ds/ds-execution-engine/#execution-rules","text":"DataNode is executed if and only if all its predecessors completed their execution with an OK status. Every time a dataNode is succesfully computed (status \"OK\"), it triggers the execution of all its successors. Graph execution is interrupted at dataNodes with an Error status. Their successors are not executed.","title":"Execution rules"},{"location":"ds/ds-execution-engine/#scheduling-instance","text":"At first start, graph is scheduled in a breadth-first order starting from source nodes. This is the first schedule instance. Some dataNodes might be updated through different ways : widget value written to dataNode, file imported into dataNode, formula modification, user refresh of dataNode, periodic behavior , chalkit scheduler API ... Such update launches the execution of the corresponding dataNode and a new scheduling instance.","title":"Scheduling instance"},{"location":"ds/ds-execution-engine/#execution-flow-control-parameters","text":"The graph execution is controlled by the execution flow control parameters specified in dataNodes.","title":"Execution flow control parameters"},{"location":"ds/ds-execution-engine/#auto-start","text":"When set to false , the associated dataNode is not executed on first execution of the dashboard nor in subsequent ones. Otherwise, i.e. when set to true , default dataNodes execution behavior applies: all nodes are executed by the Chalk'it runtime when all their predecessors successfully completed. For example, Auto Start can be set to false to avoid executing a heavy computation web-service at project load. Default value is true.","title":"Auto Start"},{"location":"ds/ds-execution-engine/#sample-time","text":"When different from 0, the dataNode is executed every sample time . It's useful for ensuring a periodic real-time execution behavior. Every time a non null sample time is defined, the execution engine computes the greatest common divisor and use it as a its base timer. Sample time is expressed in seconds and must be a multiple of 0.1s. Default value is 0.","title":"Sample Time"},{"location":"ds/ds-execution-engine/#explicit-trigger","text":"When set to true , the dataNode, in terms of execution flow control, is considered as a source node. It is no longer executed when a direct predecessor is updated. With this setting, it is only executed when it is explicitly triggered by an associated push button widget, by chalkit scheduler APIs , or by a click on the dataNode refresh icon present in the dataNodes list of tabs 1 or 3. Please refer to the Triggered POST example above. Otherwise (i.e. when set to false ), default dataNodes execution behavior applies. Useful for implementing a form-like behavior (setting independently all required dataNode inputs, without executing it with each update, then explicitly triggering its execution). Default value is false. When a direct predecessor is updated, the dataNode, with an Explicit Trigger set to true and a previous succesfull computation (status \"OK\" ), triggers the execution of all its successors.","title":"Explicit Trigger"},{"location":"ds/ds-execution-engine/#execution-flow-control-parameters-summary","text":"The table below summarizes the execution flow control parameters for the currently available dataNode types in Chalk'it. The checkbox in the table indicates that the property can be customized by the user (true or false). Otherwise, they have the default value indicated above. Type Auto Start Sample Time Explicit Trigger Variable Python Script (Pyodide) JavaScript Script (client-side) REST web-service Generic text file reader Generic binary file reader CSV file reader CSV file player Unzip file Geolocation Clock Delay Memory MQTT WebSocket receive WebSocket send Depending on the execution flow control parameters and the the data flow dependency, the dataNode execution is summarized in the following tables: For nonperiodic dataNodes (Sample Time == 0) Cases Auto Start Explicit Trigger Run at project load Run after predecessor update Run after a user trigger* 1# False False No Yes Yes 2# True False Yes Yes Yes 3# False True No No Yes 4# True True Yes No (last value) Yes *By an associated push button widget, by a click on the dataNode update icon , or by using executeDataNode API . For periodic dataNodes (Sample Time > 0) | Cases | Auto Start | Explicit Trigger | Run at project load | Run after predecessor update | Run after a user trigger* | | :----------------: | :----------------: | :----------------: | :----------------: | :----------------: | :----------------: | | 5# | False | False | No | Yes | Yes | | 6# | True | False | Yes | Yes | Yes | | 7# | False | True | No | No | Yes | | 8# | True | True | Yes | No (last value) | Yes | **For cases 7# and 8#, when the user explicitly triggers the periodic dataNode, the Explicit Trigger option is turned to False .","title":"Execution flow control parameters : summary"},{"location":"ds/ds-execution-engine/#datanodes-capabilities","text":"In addition to execution flow control parameters, dataNodes may have common capabilites depending on their type.","title":"DataNodes capabilities"},{"location":"ds/ds-execution-engine/#setinput-with-formula","text":"Python or JavaScript code can be written to define input to dataNode computation.","title":"setInput with formula"},{"location":"ds/ds-execution-engine/#setvalue-from-widget","text":"Currently only Variable and Memory dataNodes have this property. It indicates that their workspace value can be modified by widgets that have write capabilities (such as sliders ( horizontal slider ...), value , editable table ...).","title":"setValue from widget"},{"location":"ds/ds-execution-engine/#setvalue-from-file","text":"The value of the dataNode can be assigned from a file. See example in Push button .","title":"setValue from file"},{"location":"ds/ds-execution-engine/#setvalue-from-script","text":"Python or JavaScript code can be written to define input to Variable and Memory dataNodes, using chalkit API functions: setVariable setVariableProperty setVariables This is useful to init and reset variables. See example reset-counter.xprjson . The assessment of these functions is handled at the end of the current scheduling instance.","title":"setValue from script"},{"location":"ds/ds-execution-engine/#datanodes-capabilities-summary","text":"The table below summarizes currently available dataNodes in Chalk'it, as well as their major properties in terms of execution flow and data flow . Type setInput with formula setValue from widget setValue from file setValue from script Variable Python Script (Pyodide) JavaScript Script (client-side) REST web-service Generic text file reader Generic binary file reader CSV file reader CSV file player Unzip file Geolocation Clock Delay Memory MQTT WebSocket receive WebSocket send","title":"DataNodes capabilities : summary"},{"location":"ds/ds-reference/","text":"Play Reference \u00b6 DataNodes of type Variable was described in the basics section. In the following, we describe the remaining dataNode types of Chalk'it. Type Variable Python Script (Pyodide) JavaScript Script (client-side) REST web-service Generic text file reader Generic binary file reader CSV file reader CSV file player Geolocation Clock Delay Memory MQTT WebSocket receive WebSocket send Python script (Pyodide) \u00b6 It allows the evaluation of a Python script in client-side using Pyodide . Executed Python code may use the librairies available for installation in the Project librairies main tab. For further information, please read the Client-side execution with Pyodide Some examples: formula-py.xprjson rest-pandas-pyodide-covid.xprjson plotly-python-widget-py.xprjson JavaScript Script \u00b6 Similar to Python Script-type dataNodes, it is possible to write JavaScript code referencing other dataNodes, and producing JSON output to the workspace. All JavaScript librairies loaded by Chalk'it are available for use. The following ones are particularly of interest: Underscore.js Turf.js d3.js geoConversion gpx.js jQuery leaflet PapaParse SweetAlert Simple example : formula-js.xprjson REST web-services \u00b6 The dataNode type REST Web-service is used to call functions exposed as REST web-services . Input arguments may come from Chalk'it workspaces (referenced using keyword dataNodes ). The response is then evaluated in the workspace, if the call was successful. Typically, the information required to write the dataNode comes from the web-service API documentation. It may use Swagger . Parameters \u00b6 URL \u00b6 The URL of the HTTP request. The following examples illustrate Chalk'it syntax for path and how to use code to modify query arguments passed in URL. xProxy \u00b6 xProxy concept was inspired by ThingProxy . It allows to overcome web-browser CORS (Cross-Origin Resources issues) restrictions. As Chalk'it runs on a web-browser, it is subject to browser's CORS policy. Please disable xProxy if you call a localhost or private network webservice. Some examples \u00b6 Simple GET \u00b6 webservice-get.xprjson : this is a simple GET example with no input arguments. Simple POST \u00b6 webservice-post-simple-js.xprjson : this is a simple POST example with body as a JSON. GET with arguments \u00b6 webservice-get-args-js.xprjson : this example illustrates a GET call where arguments (custom path and query arguments) are defined using the urlAppend object in the body field. GET with arguments from another dataNode \u00b6 webservice-get-input-py.xprjson and webservice-get-input-js.xprjson : in this example, two variables defined in a variable dataNode are used as inputs to the GET web-service call. GET of a binary file \u00b6 xls-from-url-to-json-py.xprjson : an excel file is read from a remote URL and its content displayed. POST with arguments from another dataNode \u00b6 webservice-post-input-py.xprjson and webservice-post-input-js.xprjson : in this example, two variables defined in a variable dataNode are used as inputs to the POST web-service call. Triggered POST \u00b6 webservice-post-input-triggered-py.xprjson and webservice-post-input-triggered-js.xprjson : if the explicit trigger option is checked, the dataNode is only executed when an explicit click is performed (using a connected push button widget or the update button). When predecessors change, the dataNode execution is no longer triggered. This feature is useful for building form-like interfaces. See also Execution flow control parameters CSV file reader \u00b6 Reads a CSV file and translates its content to JSON, according to the value of ROW TO ARRAY property : If set to true , each row of the CSV file will be placed into a JavaScript Array. See example: csv-array.xprjson Otherwise, if set to false , content is parsed as an array of JSON objects. See example: csv-json.xprjson The following CSV: \"lat\",\"lng\",\"CH4\" 48.876684, 2.175765, 1.94 48.876684, 2.175765, 1.95 48.876684, 2.175765, 1.92 48.876705, 2.175806, 1.93 48.876705, 2.175806, 1.99 when ROW TO ARRAY is true , is translated to: { \"lat\" : [ 48.876684 , 48.876684 , 48.876684 , 48.876705 , 48.876705 ], \"lng\" : [ 2.175765 , 2.175765 , 2.175765 , 2.175806 , 2.175806 ], \"CH4\" : [ 1.94 , 1.95 , 1.92 , 1.93 , 1.99 ] } otherwise, it is translated to: [ { lat : 48.876684 , lng : 2.175765 , CH4 : 1.94 , }, { lat : 48.876684 , lng : 2.175765 , CH4 : 1.95 , }, { lat : 48.876684 , lng : 2.175765 , CH4 : 1.92 , }, { lat : 48.876705 , lng : 2.175806 , CH4 : 1.93 , }, { lat : 48.876705 , lng : 2.175806 , CH4 : 1.99 , }, ]; An example of table display of this CSV file is given here: csv-array-table-display.xprjson . It combines a CSV file reader as well as a formula using the underscore.js library . CSV file player \u00b6 Acts as a player of CSV file. Its behaviour depends on the TIME INCLUDED parameter: If set to false , play starts from the first row. On each SAMPLING TIME , the current row is output in JSON format and the pointer moves to the next row. See example csv-player.xprjson . Otherwise (i.e. TIME INCLUDED ), the first row is considered as a time vector. Delay \u00b6 Applies a one-step delay to its input defined in the INPUT SIGNAL field. On the first execution, its output is set to the JSON value defined in the INIT VALUE field. Example with Clock and Delay : clock-and-delay.xprjson . Memory \u00b6 Gets the previous value of a dataNode defined in the selected value of the DATANODE ORIGIN combobox. Its name is automatically generated by adding the prefix _pastValue__. On the first execution, its output is set to the JSON value defined in the INIT VALUE field. This special dataNode exhibits a distinct behavior compared to other dataNodes, as it doesn't follow the typical data flow execution. Specifically, when its DATANODE ORIGIN is executed, the memory is initiated at the subsequent scheduler start (of the same disconnected graph). With Memory dataNode, user can create counters for example, without adding real cycles in the graph. See example: memory.xprjson . In this example, the cycle between \" counter \" and \" pastValue_counter \" is a non-algebraic cycle, because of the special memory type. Clock \u00b6 Gets the value of the JavaScript clock from the web-browser which is running the Chalk'it app: { \"numeric_value\" : 1556898500713 , \"full_string_value\" : \"03/05/2019 \u00e0 17:48:20\" , \"date_string_value\" : \"03/05/2019\" , \"time_string_value\" : \"17:48:20\" , \"date_object\" : \"2019-05-03T15:48:20.713Z\" } Example with Clock and Delay : clock-and-delay.xprjson . Geolocation \u00b6 This dataNode gets the current geographical position of the device, using the GPS sensors if available. For privacy reasons, authorization is requested from the user to report its position. It also requires Chalk'it to operate under the https protocole. DataNode produces the following output. Its output value is updated automatically according to the device position and movement. Example with Geolocation dataNode and Leaflet Maps widget which displays your location : osm-geojson-geolocation.xprjson . WebSocket \u00b6 These dataNodes offers support for the WebSocket protocol , which is supported by most web browsers to offert real-time data exchange capabilities. It provides full-duplex communication channels over a single TCP connection. WebSocket in Chalk'it is implemented as client. It needs to communicate with remote WebSocket server. WebSocket receive \u00b6 Acts as a WebSocket client receiver for Chalk'it. Remote IP address : The IP address or host name for your remote WebSocket sender. Remote IP port : The port to connect to your WebSocket sender. Initialization token : Keep to None for most applications. None : nothing is sent to the web server during initialization of exchange. xMOD : support to xMOD software. The token \"ws_init\" is sent once to the xMOD WebSocket server during initialisation of exchange. Decoding options : decoding options applied on response data sent by your WebSocket sender. options Description JSON Received data are in JSON format Int8Array Received data are an Array of integer 1 byte Uint8Array Received data are an Array of unsigned integer 1 byte Int16Array Received data are an Array of integer 16 bits Uint16Array Received data are an Array of unsigned integer 16 bits Int32Array Received data are an Array of integer 32 bits Uint32Array Received data are an Array of unsigned integer 32 bits Float32Array Received data are an Array of float 32 bits (IEEE 754 single precision) Float64Array Received data are an Array of float 64 bits (IEEE 754 double precision) ArrayBuffer2String Received data are an Javascript ArrayBuffer and transform to string inside Chalk'it WebSocket send \u00b6 Acts as a WebSocket client sender for Chalk'it. JSON/JAVASCRIPT INPUT : The data sent by this dataNode to the WebSocket receiver . Data are sent without any modification. In the following example, the dataNode reads the value of \"Item\" property from the \"SelectedCmd\" dataNode and send this value to the remote WebSocket receiver as a 32-bit float. Example \u00b6 Follow instructions below to first build a WebSockets test server. Install Node.js from https://nodejs.org/ Download Node.js server example simpleWS.js Install ws library used in simpleWS.js server npm install ws Run the WebSockets server node simpleWS.js The server should be ready and display the following message: Open the websocket-demo.xprjson example with Chalk'it. Switch to View mode. Test the communication with the server. The server should display: Chalk'it should display:","title":"Reference"},{"location":"ds/ds-reference/#reference","text":"DataNodes of type Variable was described in the basics section. In the following, we describe the remaining dataNode types of Chalk'it. Type Variable Python Script (Pyodide) JavaScript Script (client-side) REST web-service Generic text file reader Generic binary file reader CSV file reader CSV file player Geolocation Clock Delay Memory MQTT WebSocket receive WebSocket send","title":"Reference"},{"location":"ds/ds-reference/#python-script-pyodide","text":"It allows the evaluation of a Python script in client-side using Pyodide . Executed Python code may use the librairies available for installation in the Project librairies main tab. For further information, please read the Client-side execution with Pyodide Some examples: formula-py.xprjson rest-pandas-pyodide-covid.xprjson plotly-python-widget-py.xprjson","title":"Python script (Pyodide)"},{"location":"ds/ds-reference/#javascript-script","text":"Similar to Python Script-type dataNodes, it is possible to write JavaScript code referencing other dataNodes, and producing JSON output to the workspace. All JavaScript librairies loaded by Chalk'it are available for use. The following ones are particularly of interest: Underscore.js Turf.js d3.js geoConversion gpx.js jQuery leaflet PapaParse SweetAlert Simple example : formula-js.xprjson","title":"JavaScript Script"},{"location":"ds/ds-reference/#rest-web-services","text":"The dataNode type REST Web-service is used to call functions exposed as REST web-services . Input arguments may come from Chalk'it workspaces (referenced using keyword dataNodes ). The response is then evaluated in the workspace, if the call was successful. Typically, the information required to write the dataNode comes from the web-service API documentation. It may use Swagger .","title":"REST web-services"},{"location":"ds/ds-reference/#parameters","text":"","title":"Parameters"},{"location":"ds/ds-reference/#url","text":"The URL of the HTTP request. The following examples illustrate Chalk'it syntax for path and how to use code to modify query arguments passed in URL.","title":"URL"},{"location":"ds/ds-reference/#xproxy","text":"xProxy concept was inspired by ThingProxy . It allows to overcome web-browser CORS (Cross-Origin Resources issues) restrictions. As Chalk'it runs on a web-browser, it is subject to browser's CORS policy. Please disable xProxy if you call a localhost or private network webservice.","title":"xProxy"},{"location":"ds/ds-reference/#some-examples","text":"","title":"Some examples"},{"location":"ds/ds-reference/#simple-get","text":"webservice-get.xprjson : this is a simple GET example with no input arguments.","title":"Simple GET"},{"location":"ds/ds-reference/#simple-post","text":"webservice-post-simple-js.xprjson : this is a simple POST example with body as a JSON.","title":"Simple POST"},{"location":"ds/ds-reference/#get-with-arguments","text":"webservice-get-args-js.xprjson : this example illustrates a GET call where arguments (custom path and query arguments) are defined using the urlAppend object in the body field.","title":"GET with arguments"},{"location":"ds/ds-reference/#get-with-arguments-from-another-datanode","text":"webservice-get-input-py.xprjson and webservice-get-input-js.xprjson : in this example, two variables defined in a variable dataNode are used as inputs to the GET web-service call.","title":"GET with arguments from another dataNode"},{"location":"ds/ds-reference/#get-of-a-binary-file","text":"xls-from-url-to-json-py.xprjson : an excel file is read from a remote URL and its content displayed.","title":"GET of a binary file"},{"location":"ds/ds-reference/#post-with-arguments-from-another-datanode","text":"webservice-post-input-py.xprjson and webservice-post-input-js.xprjson : in this example, two variables defined in a variable dataNode are used as inputs to the POST web-service call.","title":"POST with arguments from another dataNode"},{"location":"ds/ds-reference/#triggered-post","text":"webservice-post-input-triggered-py.xprjson and webservice-post-input-triggered-js.xprjson : if the explicit trigger option is checked, the dataNode is only executed when an explicit click is performed (using a connected push button widget or the update button). When predecessors change, the dataNode execution is no longer triggered. This feature is useful for building form-like interfaces. See also Execution flow control parameters","title":"Triggered POST"},{"location":"ds/ds-reference/#csv-file-reader","text":"Reads a CSV file and translates its content to JSON, according to the value of ROW TO ARRAY property : If set to true , each row of the CSV file will be placed into a JavaScript Array. See example: csv-array.xprjson Otherwise, if set to false , content is parsed as an array of JSON objects. See example: csv-json.xprjson The following CSV: \"lat\",\"lng\",\"CH4\" 48.876684, 2.175765, 1.94 48.876684, 2.175765, 1.95 48.876684, 2.175765, 1.92 48.876705, 2.175806, 1.93 48.876705, 2.175806, 1.99 when ROW TO ARRAY is true , is translated to: { \"lat\" : [ 48.876684 , 48.876684 , 48.876684 , 48.876705 , 48.876705 ], \"lng\" : [ 2.175765 , 2.175765 , 2.175765 , 2.175806 , 2.175806 ], \"CH4\" : [ 1.94 , 1.95 , 1.92 , 1.93 , 1.99 ] } otherwise, it is translated to: [ { lat : 48.876684 , lng : 2.175765 , CH4 : 1.94 , }, { lat : 48.876684 , lng : 2.175765 , CH4 : 1.95 , }, { lat : 48.876684 , lng : 2.175765 , CH4 : 1.92 , }, { lat : 48.876705 , lng : 2.175806 , CH4 : 1.93 , }, { lat : 48.876705 , lng : 2.175806 , CH4 : 1.99 , }, ]; An example of table display of this CSV file is given here: csv-array-table-display.xprjson . It combines a CSV file reader as well as a formula using the underscore.js library .","title":"CSV file reader"},{"location":"ds/ds-reference/#csv-file-player","text":"Acts as a player of CSV file. Its behaviour depends on the TIME INCLUDED parameter: If set to false , play starts from the first row. On each SAMPLING TIME , the current row is output in JSON format and the pointer moves to the next row. See example csv-player.xprjson . Otherwise (i.e. TIME INCLUDED ), the first row is considered as a time vector.","title":"CSV file player"},{"location":"ds/ds-reference/#delay","text":"Applies a one-step delay to its input defined in the INPUT SIGNAL field. On the first execution, its output is set to the JSON value defined in the INIT VALUE field. Example with Clock and Delay : clock-and-delay.xprjson .","title":"Delay"},{"location":"ds/ds-reference/#memory","text":"Gets the previous value of a dataNode defined in the selected value of the DATANODE ORIGIN combobox. Its name is automatically generated by adding the prefix _pastValue__. On the first execution, its output is set to the JSON value defined in the INIT VALUE field. This special dataNode exhibits a distinct behavior compared to other dataNodes, as it doesn't follow the typical data flow execution. Specifically, when its DATANODE ORIGIN is executed, the memory is initiated at the subsequent scheduler start (of the same disconnected graph). With Memory dataNode, user can create counters for example, without adding real cycles in the graph. See example: memory.xprjson . In this example, the cycle between \" counter \" and \" pastValue_counter \" is a non-algebraic cycle, because of the special memory type.","title":"Memory"},{"location":"ds/ds-reference/#clock","text":"Gets the value of the JavaScript clock from the web-browser which is running the Chalk'it app: { \"numeric_value\" : 1556898500713 , \"full_string_value\" : \"03/05/2019 \u00e0 17:48:20\" , \"date_string_value\" : \"03/05/2019\" , \"time_string_value\" : \"17:48:20\" , \"date_object\" : \"2019-05-03T15:48:20.713Z\" } Example with Clock and Delay : clock-and-delay.xprjson .","title":"Clock"},{"location":"ds/ds-reference/#geolocation","text":"This dataNode gets the current geographical position of the device, using the GPS sensors if available. For privacy reasons, authorization is requested from the user to report its position. It also requires Chalk'it to operate under the https protocole. DataNode produces the following output. Its output value is updated automatically according to the device position and movement. Example with Geolocation dataNode and Leaflet Maps widget which displays your location : osm-geojson-geolocation.xprjson .","title":"Geolocation"},{"location":"ds/ds-reference/#websocket","text":"These dataNodes offers support for the WebSocket protocol , which is supported by most web browsers to offert real-time data exchange capabilities. It provides full-duplex communication channels over a single TCP connection. WebSocket in Chalk'it is implemented as client. It needs to communicate with remote WebSocket server.","title":"WebSocket"},{"location":"ds/ds-reference/#websocket-receive","text":"Acts as a WebSocket client receiver for Chalk'it. Remote IP address : The IP address or host name for your remote WebSocket sender. Remote IP port : The port to connect to your WebSocket sender. Initialization token : Keep to None for most applications. None : nothing is sent to the web server during initialization of exchange. xMOD : support to xMOD software. The token \"ws_init\" is sent once to the xMOD WebSocket server during initialisation of exchange. Decoding options : decoding options applied on response data sent by your WebSocket sender. options Description JSON Received data are in JSON format Int8Array Received data are an Array of integer 1 byte Uint8Array Received data are an Array of unsigned integer 1 byte Int16Array Received data are an Array of integer 16 bits Uint16Array Received data are an Array of unsigned integer 16 bits Int32Array Received data are an Array of integer 32 bits Uint32Array Received data are an Array of unsigned integer 32 bits Float32Array Received data are an Array of float 32 bits (IEEE 754 single precision) Float64Array Received data are an Array of float 64 bits (IEEE 754 double precision) ArrayBuffer2String Received data are an Javascript ArrayBuffer and transform to string inside Chalk'it","title":"WebSocket receive"},{"location":"ds/ds-reference/#websocket-send","text":"Acts as a WebSocket client sender for Chalk'it. JSON/JAVASCRIPT INPUT : The data sent by this dataNode to the WebSocket receiver . Data are sent without any modification. In the following example, the dataNode reads the value of \"Item\" property from the \"SelectedCmd\" dataNode and send this value to the remote WebSocket receiver as a 32-bit float.","title":"WebSocket send"},{"location":"ds/ds-reference/#example","text":"Follow instructions below to first build a WebSockets test server. Install Node.js from https://nodejs.org/ Download Node.js server example simpleWS.js Install ws library used in simpleWS.js server npm install ws Run the WebSockets server node simpleWS.js The server should be ready and display the following message: Open the websocket-demo.xprjson example with Chalk'it. Switch to View mode. Test the communication with the server. The server should display: Chalk'it should display:","title":"Example"},{"location":"ds/ds/","text":"DataNodes \u00b6 DataNodes are functions or variables that produce JSON or Python objects into the workspace. Chalk'it maintains a workspace of these objects whose content corresponds to the latest dataNodes evaluation. Chalk'it allows the user to specify a dataflow diagram of both data and execution dependency relationships between dataNodes. This constitutes the application logic. Basics Execution engine Reference","title":"Introduction"},{"location":"ds/ds/#datanodes","text":"DataNodes are functions or variables that produce JSON or Python objects into the workspace. Chalk'it maintains a workspace of these objects whose content corresponds to the latest dataNodes evaluation. Chalk'it allows the user to specify a dataflow diagram of both data and execution dependency relationships between dataNodes. This constitutes the application logic. Basics Execution engine Reference","title":"DataNodes"},{"location":"export/export/","text":"Application export, deployment and sharing \u00b6 An Chalk'it project may be: previewed in full-page view exported to a standalone html page on the local disk These features are available in the dashboard view mode: As dashboard edition zone is smaller than the full window, Chalk'it provides several scaling methods, available under the settings menu shown below: Available export settings depend on the responsive layout configuration defined in the edit mode: If Row is set to none, the dashboard is unconstrained . Available scaing methods are adjustToFullWidth , ajustToTargetWindow and keepOriginalWidth If Row is set a a numeric value (1,2...), the dashboard in edition mode is organized according to this constrained layout. In the target dashboard, each row is projected to the target full page. Several pagination methods are available, including: projectToTargetWindow , rowToPage , rowToTab and customNavigation Scaling methods for the unconstrained dashboard \u00b6 adjustToFullWidth \u00b6 The dashboard is stretched widthwise to fit the width of the target screen. The height of the widgets is calculated so as to preserve their proportions (in pixels). User should use this method rather than the ajustToTargetWindow method if the widgets proportions must be preserved (in pixels), e.g. to avoid distortion of an image. Of course, a vertical overflow (with vertical scroll bar) is possible in this mode. ajustToTargetWindow \u00b6 Similar to the adjustToFullWidth method, but the widgets proportions are not preserved. Dashboard viewport proportion, from the width and height dimensions, are preserved. This method is useful to keep the same dashboard content heightwise. keepOriginalWidth \u00b6 Original viewport dimensions of the dashboard are preserved. Dashboard is centered. Scaling methods for the constrained dashboard \u00b6 projectToTargetWindow \u00b6 This method makes the whole dashboard fits the entire target screen. The original dashboard (in edition mode), seen with its scroll dimensions, is \"projected\" into the target screen. Target screen has no overflow (no scroll bars). Widgets proportions are not preserved. User should use this method when rows are defined in responsive layout, as each row will be projected into the target screen (for large target screens). For small target screens, each column will be projected into the target screen. This method is not suitable if the scroll height of the original dashboard is approximatively greater than 130 % of the original screen, when no row is used. rowToPage \u00b6 Each row of the dashboard fits the entire target screen. Only one row displayed at a time. A pagination system is included. rowToTab \u00b6 Each row of the dashboard fits the entire target screen. Only one row displayed at a time as a page tab. Tab names have to be be defined in the Configuration of each row's name modal in the Dashboard aspect main tabset: customNavigation \u00b6 Custom navigation mode is the most flexible multi-page mode. For navigation between pages, user needs to use button widgets connected to a JavaScript Script datanode including navigation instructions: chalkit . goToPage ( 2 ); return true ; Default start page needs also to be indicated: Security considerations \u00b6 When a HTML page is generated with Chalk'it, either exported, public or private, the xprjson content is inlined into the HTML page code, and might include sensitive information such as passwords, API keys, authorization information... Safely handling secrets is currenly outside Chalk'it scope.","title":"Export"},{"location":"export/export/#application-export-deployment-and-sharing","text":"An Chalk'it project may be: previewed in full-page view exported to a standalone html page on the local disk These features are available in the dashboard view mode: As dashboard edition zone is smaller than the full window, Chalk'it provides several scaling methods, available under the settings menu shown below: Available export settings depend on the responsive layout configuration defined in the edit mode: If Row is set to none, the dashboard is unconstrained . Available scaing methods are adjustToFullWidth , ajustToTargetWindow and keepOriginalWidth If Row is set a a numeric value (1,2...), the dashboard in edition mode is organized according to this constrained layout. In the target dashboard, each row is projected to the target full page. Several pagination methods are available, including: projectToTargetWindow , rowToPage , rowToTab and customNavigation","title":"Application export, deployment and sharing"},{"location":"export/export/#scaling-methods-for-the-unconstrained-dashboard","text":"","title":"Scaling methods for the unconstrained dashboard"},{"location":"export/export/#adjusttofullwidth","text":"The dashboard is stretched widthwise to fit the width of the target screen. The height of the widgets is calculated so as to preserve their proportions (in pixels). User should use this method rather than the ajustToTargetWindow method if the widgets proportions must be preserved (in pixels), e.g. to avoid distortion of an image. Of course, a vertical overflow (with vertical scroll bar) is possible in this mode.","title":"adjustToFullWidth"},{"location":"export/export/#ajusttotargetwindow","text":"Similar to the adjustToFullWidth method, but the widgets proportions are not preserved. Dashboard viewport proportion, from the width and height dimensions, are preserved. This method is useful to keep the same dashboard content heightwise.","title":"ajustToTargetWindow"},{"location":"export/export/#keeporiginalwidth","text":"Original viewport dimensions of the dashboard are preserved. Dashboard is centered.","title":"keepOriginalWidth"},{"location":"export/export/#scaling-methods-for-the-constrained-dashboard","text":"","title":"Scaling methods for the constrained dashboard"},{"location":"export/export/#projecttotargetwindow","text":"This method makes the whole dashboard fits the entire target screen. The original dashboard (in edition mode), seen with its scroll dimensions, is \"projected\" into the target screen. Target screen has no overflow (no scroll bars). Widgets proportions are not preserved. User should use this method when rows are defined in responsive layout, as each row will be projected into the target screen (for large target screens). For small target screens, each column will be projected into the target screen. This method is not suitable if the scroll height of the original dashboard is approximatively greater than 130 % of the original screen, when no row is used.","title":"projectToTargetWindow"},{"location":"export/export/#rowtopage","text":"Each row of the dashboard fits the entire target screen. Only one row displayed at a time. A pagination system is included.","title":"rowToPage"},{"location":"export/export/#rowtotab","text":"Each row of the dashboard fits the entire target screen. Only one row displayed at a time as a page tab. Tab names have to be be defined in the Configuration of each row's name modal in the Dashboard aspect main tabset:","title":"rowToTab"},{"location":"export/export/#customnavigation","text":"Custom navigation mode is the most flexible multi-page mode. For navigation between pages, user needs to use button widgets connected to a JavaScript Script datanode including navigation instructions: chalkit . goToPage ( 2 ); return true ; Default start page needs also to be indicated:","title":"customNavigation"},{"location":"export/export/#security-considerations","text":"When a HTML page is generated with Chalk'it, either exported, public or private, the xprjson content is inlined into the HTML page code, and might include sensitive information such as passwords, API keys, authorization information... Safely handling secrets is currenly outside Chalk'it scope.","title":"Security considerations"},{"location":"py/py-index/","text":"Python with Chalk'it \u00b6 There are multiple solutions for using Python with Chalk'it. You may either use Pyodide or Python webapp frameworks such as Django or Flask . Chalk'it Pyodide Local prototyping with Flask","title":"Introduction"},{"location":"py/py-index/#python-with-chalkit","text":"There are multiple solutions for using Python with Chalk'it. You may either use Pyodide or Python webapp frameworks such as Django or Flask . Chalk'it Pyodide Local prototyping with Flask","title":"Python with Chalk'it"},{"location":"py/py-proto-flask/","text":"Local prototyping with Flask \u00b6 Flask pacakge allows to simply run a Python script as a webservice. This can be easily done as illustrated below. Setup instructions \u00b6 Download Python 3.7.2 (or another Python version >= 3.6) from https://www.python.org/downloads/ and install it Install required packages to create a web-service from your Python code pip install flask pip install flask_restful pip install flask_cors Install commonly used packages for scientific computing : pip install numpy pip install scipy If you are behind a proxy, you might need to specify it. Example : pip --proxy our-proxy:8082 install numpy Simple template \u00b6 Download this simple template and save it to template-python-ws.py file. from flask import Flask , request from flask_restful import Resource , Api from flask_cors import CORS import json import numpy as np app = Flask ( __name__ ) CORS ( app ) api = Api ( app ) class Test ( Resource ): def post ( self ): input = json . loads ( request . data ) A = input [ \"A\" ] B = input [ \"B\" ] sum = np . add ( A , B ) product = np . multiply ( A , B ) output = { \"sum\" : sum . tolist (), \"product\" : product . tolist () } return output api . add_resource ( Test , '/basicVect' ) if __name__ == '__main__' : app . run ( debug = True ) then run: python template-python-ws.py your server should be listening on localhost, port 5000. Chalk'it project \u00b6 Open the following simple Chalk'it project to test the python web-service. python-webservice.xprjson","title":"Local prototyping with Flask"},{"location":"py/py-proto-flask/#local-prototyping-with-flask","text":"Flask pacakge allows to simply run a Python script as a webservice. This can be easily done as illustrated below.","title":"Local prototyping with Flask"},{"location":"py/py-proto-flask/#setup-instructions","text":"Download Python 3.7.2 (or another Python version >= 3.6) from https://www.python.org/downloads/ and install it Install required packages to create a web-service from your Python code pip install flask pip install flask_restful pip install flask_cors Install commonly used packages for scientific computing : pip install numpy pip install scipy If you are behind a proxy, you might need to specify it. Example : pip --proxy our-proxy:8082 install numpy","title":"Setup instructions"},{"location":"py/py-proto-flask/#simple-template","text":"Download this simple template and save it to template-python-ws.py file. from flask import Flask , request from flask_restful import Resource , Api from flask_cors import CORS import json import numpy as np app = Flask ( __name__ ) CORS ( app ) api = Api ( app ) class Test ( Resource ): def post ( self ): input = json . loads ( request . data ) A = input [ \"A\" ] B = input [ \"B\" ] sum = np . add ( A , B ) product = np . multiply ( A , B ) output = { \"sum\" : sum . tolist (), \"product\" : product . tolist () } return output api . add_resource ( Test , '/basicVect' ) if __name__ == '__main__' : app . run ( debug = True ) then run: python template-python-ws.py your server should be listening on localhost, port 5000.","title":"Simple template"},{"location":"py/py-proto-flask/#chalkit-project","text":"Open the following simple Chalk'it project to test the python web-service. python-webservice.xprjson","title":"Chalk'it project"},{"location":"py/py-pyodide/","text":"Pyodide in few works \u00b6 Pyodide is a package that allows to use the Python programming language within a web browser, by running it in web-assembly. It is designed to be used as a scientific computing platform, and includes many libraries and tools commonly used in scientific and numerical computing, such as NumPy and Matplotlib. Pyodide allows to use these libraries and tools directly from your JavaScript code, without the need to write any Python code yourself or set up a separate Python environment on your machine. Instead, you can just include Pyodide in your web page, and then use its API to access the Python libraries and run Python code within the context of your web page. Chalk'it has the ability to run your Python code with Pyodide and make it interoperate with JavaScript. Supported librairies \u00b6 Chalk'it supports the two ways of importing Pyodide librairies : Pre-built packages (loaded with pyodide.loadPackage) : https://pyodide.org/en/stable/usage/packages-in-pyodide.html Micropip packages (tested with Chalk'it) Drawbacks of using Pyodide \u00b6 There are a few potential drawbacks to using Pyodide: Pyodide is not a full implementation of Python, and it may not support all Python libraries and features. Some Python libraries that rely on C extensions or require access to the operating system may not be compatible with Pyodide. Pyodide is designed to run within the browser, so it may not have the same level of performance as a native Python installation. Pyodide is still a relatively new project, and it may not be as mature or well-documented as other Python environments. Pyodide requires a recent version of a web browser that supports WebAssembly, so it may not work on older or less mainstream browsers. Because Pyodide runs within the browser, it may be subject to the same security and privacy concerns as other web-based technologies. You should be careful about running untrusted code within Pyodide, and consider the potential risks of exposing your data or code to the wider internet.","title":"Pyodide"},{"location":"py/py-pyodide/#pyodide-in-few-works","text":"Pyodide is a package that allows to use the Python programming language within a web browser, by running it in web-assembly. It is designed to be used as a scientific computing platform, and includes many libraries and tools commonly used in scientific and numerical computing, such as NumPy and Matplotlib. Pyodide allows to use these libraries and tools directly from your JavaScript code, without the need to write any Python code yourself or set up a separate Python environment on your machine. Instead, you can just include Pyodide in your web page, and then use its API to access the Python libraries and run Python code within the context of your web page. Chalk'it has the ability to run your Python code with Pyodide and make it interoperate with JavaScript.","title":"Pyodide in few works"},{"location":"py/py-pyodide/#supported-librairies","text":"Chalk'it supports the two ways of importing Pyodide librairies : Pre-built packages (loaded with pyodide.loadPackage) : https://pyodide.org/en/stable/usage/packages-in-pyodide.html Micropip packages (tested with Chalk'it)","title":"Supported librairies"},{"location":"py/py-pyodide/#drawbacks-of-using-pyodide","text":"There are a few potential drawbacks to using Pyodide: Pyodide is not a full implementation of Python, and it may not support all Python libraries and features. Some Python libraries that rely on C extensions or require access to the operating system may not be compatible with Pyodide. Pyodide is designed to run within the browser, so it may not have the same level of performance as a native Python installation. Pyodide is still a relatively new project, and it may not be as mature or well-documented as other Python environments. Pyodide requires a recent version of a web browser that supports WebAssembly, so it may not work on older or less mainstream browsers. Because Pyodide runs within the browser, it may be subject to the same security and privacy concerns as other web-based technologies. You should be careful about running untrusted code within Pyodide, and consider the potential risks of exposing your data or code to the wider internet.","title":"Drawbacks of using Pyodide"},{"location":"quick-start/quickstart/","text":"Quickstart : A journey throught the Iris dataset \u00b6 Introduction \u00b6 The Iris flower dataset is a multivariate dataset introduced by the British statistician and biologist Ronald Fisher in his 1936 paper \"The use of multiple measurements in taxonomic problems\" as an example of linear discriminant analysis. It consists of 50 samples from each of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Four features were measured from each sample: the length and the width of the sepals and petals, in centimeters. The Iris dataset is widely used in machine learning as a benchmark dataset for statistical classification algorithms. It is free and publicly avaible at the UCI Machine Repository . The following tutorial allows to illustrate main Chalk'it features througth this dataset. Expected result is provided in the following project: iris-tutorial.xprjson 1. Create a projet \u00b6 Run Chalk'it in the command line: chalk-it Then, click My Project button to reach project editor on the Discover Chalk'it menu. Name the new projet iris-tutorial by filling the title form, then save it using the Save button. An iris-tutorial.xprjson is then created in your current directory (directory where the chalk-it command was run). 2. Load required Python Pyodide librairies \u00b6 Using the Project librairies main tab, load the following required librairies: pandas , scikit-learn (from the Standard Librairies tabset) and plotly (from the Micropip Librairies tabset). Use the search bar to ease the process. 3. Load dataset data \u00b6 Create a datanode named dataset to load the Iris dataset from Scikit-learn by following the next instructions: Click on Datanodes main tab, then on New button: Select Script (Pyodide) from the list of datanode types: Enter dataset in the NAME field and copy the following code into the PYTHON SCRIPT field: from sklearn import datasets iris = datasets . load_iris () return iris This step is illustrated below: Finally, click on Save button for validation. Datanode execution status and result are now available and can be previewed in the dataset window as follows: 4. Visualize the dataset \u00b6 Visualize the dataset in 4 steps: Step1: prepare the data \u00b6 To load the dataset in a Pandas dataframe, follow the procedure described in paragraph 2. to create a new Script (Pyodide) datanode. The main differences are: Enter datasetDataframe in NAME field, Copy the following code in PYTHON SCRIPT field. import pandas as pd iris = dataNodes [ \"dataset\" ] df = pd . DataFrame ( data = iris . data , columns = iris . feature_names ) df [ \"target\" ] = iris . target target_names = { 0 : \"Setosa\" , 1 : \"Versicolour\" , 2 : \"Virginica\" } df [ 'target' ] = df [ 'target' ] . map ( target_names ) return df The expression dataNodes[\"dataset\"] indicates Chalk'it to read the last execution output of the dataset datanode. It also establishes a data and execution flow dependency between dataset and datasetDataframe . To visualize the dataset using Plotly Python librairy, create a new Script (Pyodide) datanode, name it plot , then copy the following code in PYTHON SCRIPT field. import plotly.express as px df = dataNodes [ \"datasetDataframe\" ] fig = px . scatter ( df , x = \"sepal width (cm)\" , y = \"sepal length (cm)\" , color = \"target\" , size = 'petal length (cm)' , hover_data = [ 'petal width (cm)' ]) return fig Step2: create the dashboard \u00b6 To browse the widgets libraries, click on Widgets main tab, then open the Plots category as shown below: To add a Plotly Python widget to the dashboard editor, click on the corresponding icon or just perform a drag and drop. Step3: connect dataNode to widget \u00b6 Click on the pencil icon on the top-right corner of the widget to display the widget menu. Select then Connect widget as shown below: A panel will then be displayed on the right-side of the screen. From the connection dropdown, select the datanode plot , as it will provide the figure object needed for the widget. Click Save to validate the choice. Step4: Preview the dashboard \u00b6 A static preview of the figure is then provided. The widget can be moved or resized as needed. The *View* mode can be selected to start interactive visualization. 5. Interactive predictor with classifier training \u00b6 The goal is now to use the previously trained classifier to predict Iris species based on petal and sepal width and length. Classifier training \u00b6 Following the steps already described in paragraph 2. , create a Script (Pyodide) datanode named classifier and use the following python script as shown in the picture below. from sklearn.ensemble import RandomForestClassifier clf = RandomForestClassifier () clf . fit ( dataNodes [ \"dataset\" ] . data , dataNodes [ \"dataset\" ] . target ) return clf The result should look like: Interactive predictor \u00b6 Create a JSON Variable datanode named inputs using JavaScript workspace variable type. Use the following JSON definition: { \"sepal_width\" : 5.4 , \"sepal_length\" : 2.7 , \"petal_length\" : 3 , \"petal_width\" : 0.5 } The result should be as follow: Add four horizontal sliders to pilot the values of \"sepal width\",\"sepal_length\", \"petal_length\" and \"petal_width\". First click the _Widgets main tab, then basic inputs & controls . Connect each slider to its corresponding feature as shown below: Configure sliders properties with a sliding step of 0.1 and min/max values as stated in the following table: Feature min max sepal_width 4.3 7.9 sepal_length 2.0 4.4 petal_width 0.1 2.5 petal_length 1.0 6.9 For this purpose, select the Graphical properties tab of each widget as illustrated below: Add a Script (Pyodide) datanode named predict with the following code: import pandas as pd from sklearn.ensemble import RandomForestClassifier df = pd . DataFrame ( dataNodes [ \"inputs\" ], index = [ 0 ]) clf = dataNodes [ \"classifier\" ] prediction = clf . predict ( df ) return dataNodes [ \"dataset\" ] . target_names [ prediction ][ 0 ] Go back to the Widgets main tab, open the Basic Displays tabset, and then add a KPI value widget Connect this widget to the predict datanode. Switch to *View* mode. Use the sliders to change Iris features and view prediction result accordingly: Note that computation will be triggered every time a slider is changed. Explicit trigger Sometimes a different behaviour is needed, a form-like behaviour where the predictor execution is triggered only when a button is clicked. This behaviour can be achieved through the following steps : Switch to *Edit* mode. Add a button widget, connect it to the predict datanode, and name it Run . Open the datanode predict , switch the EXPLICIT TRIGGER parameter to YES . Switch back to *View* mode to test the new behaviour. This project, when finished, can be previewed or exported to a standalone HTML page or your app can be deployed and shared using a public or a private link.","title":"Quickstart"},{"location":"quick-start/quickstart/#quickstart-a-journey-throught-the-iris-dataset","text":"","title":"Quickstart : A journey throught the Iris dataset"},{"location":"quick-start/quickstart/#introduction","text":"The Iris flower dataset is a multivariate dataset introduced by the British statistician and biologist Ronald Fisher in his 1936 paper \"The use of multiple measurements in taxonomic problems\" as an example of linear discriminant analysis. It consists of 50 samples from each of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Four features were measured from each sample: the length and the width of the sepals and petals, in centimeters. The Iris dataset is widely used in machine learning as a benchmark dataset for statistical classification algorithms. It is free and publicly avaible at the UCI Machine Repository . The following tutorial allows to illustrate main Chalk'it features througth this dataset. Expected result is provided in the following project: iris-tutorial.xprjson","title":"Introduction"},{"location":"quick-start/quickstart/#1-create-a-projet","text":"Run Chalk'it in the command line: chalk-it Then, click My Project button to reach project editor on the Discover Chalk'it menu. Name the new projet iris-tutorial by filling the title form, then save it using the Save button. An iris-tutorial.xprjson is then created in your current directory (directory where the chalk-it command was run).","title":"1. Create a projet"},{"location":"quick-start/quickstart/#2-load-required-python-pyodide-librairies","text":"Using the Project librairies main tab, load the following required librairies: pandas , scikit-learn (from the Standard Librairies tabset) and plotly (from the Micropip Librairies tabset). Use the search bar to ease the process.","title":"2. Load required Python Pyodide librairies"},{"location":"quick-start/quickstart/#3-load-dataset-data","text":"Create a datanode named dataset to load the Iris dataset from Scikit-learn by following the next instructions: Click on Datanodes main tab, then on New button: Select Script (Pyodide) from the list of datanode types: Enter dataset in the NAME field and copy the following code into the PYTHON SCRIPT field: from sklearn import datasets iris = datasets . load_iris () return iris This step is illustrated below: Finally, click on Save button for validation. Datanode execution status and result are now available and can be previewed in the dataset window as follows:","title":"3. Load dataset data"},{"location":"quick-start/quickstart/#4-visualize-the-dataset","text":"Visualize the dataset in 4 steps:","title":"4. Visualize the dataset"},{"location":"quick-start/quickstart/#step1-prepare-the-data","text":"To load the dataset in a Pandas dataframe, follow the procedure described in paragraph 2. to create a new Script (Pyodide) datanode. The main differences are: Enter datasetDataframe in NAME field, Copy the following code in PYTHON SCRIPT field. import pandas as pd iris = dataNodes [ \"dataset\" ] df = pd . DataFrame ( data = iris . data , columns = iris . feature_names ) df [ \"target\" ] = iris . target target_names = { 0 : \"Setosa\" , 1 : \"Versicolour\" , 2 : \"Virginica\" } df [ 'target' ] = df [ 'target' ] . map ( target_names ) return df The expression dataNodes[\"dataset\"] indicates Chalk'it to read the last execution output of the dataset datanode. It also establishes a data and execution flow dependency between dataset and datasetDataframe . To visualize the dataset using Plotly Python librairy, create a new Script (Pyodide) datanode, name it plot , then copy the following code in PYTHON SCRIPT field. import plotly.express as px df = dataNodes [ \"datasetDataframe\" ] fig = px . scatter ( df , x = \"sepal width (cm)\" , y = \"sepal length (cm)\" , color = \"target\" , size = 'petal length (cm)' , hover_data = [ 'petal width (cm)' ]) return fig","title":"Step1: prepare the data"},{"location":"quick-start/quickstart/#step2-create-the-dashboard","text":"To browse the widgets libraries, click on Widgets main tab, then open the Plots category as shown below: To add a Plotly Python widget to the dashboard editor, click on the corresponding icon or just perform a drag and drop.","title":"Step2: create the dashboard"},{"location":"quick-start/quickstart/#step3-connect-datanode-to-widget","text":"Click on the pencil icon on the top-right corner of the widget to display the widget menu. Select then Connect widget as shown below: A panel will then be displayed on the right-side of the screen. From the connection dropdown, select the datanode plot , as it will provide the figure object needed for the widget. Click Save to validate the choice.","title":"Step3: connect dataNode to widget"},{"location":"quick-start/quickstart/#step4-preview-the-dashboard","text":"A static preview of the figure is then provided. The widget can be moved or resized as needed. The *View* mode can be selected to start interactive visualization.","title":"Step4: Preview the dashboard"},{"location":"quick-start/quickstart/#5-interactive-predictor-with-classifier-training","text":"The goal is now to use the previously trained classifier to predict Iris species based on petal and sepal width and length.","title":"5. Interactive predictor with classifier training"},{"location":"quick-start/quickstart/#classifier-training","text":"Following the steps already described in paragraph 2. , create a Script (Pyodide) datanode named classifier and use the following python script as shown in the picture below. from sklearn.ensemble import RandomForestClassifier clf = RandomForestClassifier () clf . fit ( dataNodes [ \"dataset\" ] . data , dataNodes [ \"dataset\" ] . target ) return clf The result should look like:","title":"Classifier training"},{"location":"quick-start/quickstart/#interactive-predictor","text":"Create a JSON Variable datanode named inputs using JavaScript workspace variable type. Use the following JSON definition: { \"sepal_width\" : 5.4 , \"sepal_length\" : 2.7 , \"petal_length\" : 3 , \"petal_width\" : 0.5 } The result should be as follow: Add four horizontal sliders to pilot the values of \"sepal width\",\"sepal_length\", \"petal_length\" and \"petal_width\". First click the _Widgets main tab, then basic inputs & controls . Connect each slider to its corresponding feature as shown below: Configure sliders properties with a sliding step of 0.1 and min/max values as stated in the following table: Feature min max sepal_width 4.3 7.9 sepal_length 2.0 4.4 petal_width 0.1 2.5 petal_length 1.0 6.9 For this purpose, select the Graphical properties tab of each widget as illustrated below: Add a Script (Pyodide) datanode named predict with the following code: import pandas as pd from sklearn.ensemble import RandomForestClassifier df = pd . DataFrame ( dataNodes [ \"inputs\" ], index = [ 0 ]) clf = dataNodes [ \"classifier\" ] prediction = clf . predict ( df ) return dataNodes [ \"dataset\" ] . target_names [ prediction ][ 0 ] Go back to the Widgets main tab, open the Basic Displays tabset, and then add a KPI value widget Connect this widget to the predict datanode. Switch to *View* mode. Use the sliders to change Iris features and view prediction result accordingly: Note that computation will be triggered every time a slider is changed. Explicit trigger Sometimes a different behaviour is needed, a form-like behaviour where the predictor execution is triggered only when a button is clicked. This behaviour can be achieved through the following steps : Switch to *Edit* mode. Add a button widget, connect it to the predict datanode, and name it Run . Open the datanode predict , switch the EXPLICIT TRIGGER parameter to YES . Switch back to *View* mode to test the new behaviour. This project, when finished, can be previewed or exported to a standalone HTML page or your app can be deployed and shared using a public or a private link.","title":"Interactive predictor"},{"location":"wdg/plot-themes/","text":"Plots themes \u00b6 Plotly \u00b6 As of now, plotly line, bars and pie are themed along the other widgets. 3D widgets are also partially customized. But Generic and Real Time need customization from the user. To do so, they will need to create a new datanode \"layout\" object and then apply it to the \"Layout\" actuator. Here is an example of the structure of the layout object: var layout = { \"xaxis\" : { \"tickfont\" : { \"color\" : \"var(--widget-color)\" } }, \"yaxis\" : { \"tickfont\" : { \"color\" : \"var(--widget-color)\" } }, \"zaxis\" : { \"tickfont\" : { \"color\" : \"var(--widget-color)\" } }, \"paper_bgcolor\" : \"rgba(0,0,0,0)\" , \"plot_bgcolor\" : \"rgba(0,0,0,0)\" , \"colorway\" : [ \"var(--widget-color-2)\" , \"var(--widget-color-5)\" , \"var(--widget-color-6)\" , \"var(--widget-color-7)\" ], \"legend\" : { \"font\" : { \"color\" : \"var(--widget-color)\" , } } }; return layout ; This example shows all colors in the Plotly config for wich we support CSS Custom Properties (ie. var(---widget-color) ). To be perfectly clear about Themes colors, each Theme has 8 colors. Here is how they are used: var ( --widget-color-0 ); // Project background color , if not overriden with the color picker in the \"Dashboard Panel\" left sidebar panel var ( --widget-color-1 ); // Text color , same as var ( --widget-color ) var ( --widget-color-2 ); // Primary color var ( --widget-color-3 ); // Active color , derivated from the primary color var ( --widget-color-4 ); // Hove color , derivated from the primary color var ( --widget-color-5 ); // Accent color , used for charts var ( --widget-color-6 ); // Accent color , used for charts var ( --widget-color-7 ); // Accent color , used for charts Theses colors can not be overriden globally. For Plotly charts types Line, Bars and Pie, they can be overriden in the widget \"Graphical Properties\" right side bar, for each chart individually . eCharts \u00b6 eCharts widgets needs an \"option\" datanodes to be functionnal. Inside this datanode, the user can add datas and a lots of parameters like colors. By default, the color key inside the option object is not defined, we automatically apply colors to match the current project theme like so: var option = { \"color\" : [ \"var(--widget-color-2)\" , \"var(--widget-color-5)\" , \"var(--widget-color-6)\" , \"var(--widget-color-7)\" ] }; return option ;","title":"Themes"},{"location":"wdg/plot-themes/#plots-themes","text":"","title":"Plots themes"},{"location":"wdg/plot-themes/#plotly","text":"As of now, plotly line, bars and pie are themed along the other widgets. 3D widgets are also partially customized. But Generic and Real Time need customization from the user. To do so, they will need to create a new datanode \"layout\" object and then apply it to the \"Layout\" actuator. Here is an example of the structure of the layout object: var layout = { \"xaxis\" : { \"tickfont\" : { \"color\" : \"var(--widget-color)\" } }, \"yaxis\" : { \"tickfont\" : { \"color\" : \"var(--widget-color)\" } }, \"zaxis\" : { \"tickfont\" : { \"color\" : \"var(--widget-color)\" } }, \"paper_bgcolor\" : \"rgba(0,0,0,0)\" , \"plot_bgcolor\" : \"rgba(0,0,0,0)\" , \"colorway\" : [ \"var(--widget-color-2)\" , \"var(--widget-color-5)\" , \"var(--widget-color-6)\" , \"var(--widget-color-7)\" ], \"legend\" : { \"font\" : { \"color\" : \"var(--widget-color)\" , } } }; return layout ; This example shows all colors in the Plotly config for wich we support CSS Custom Properties (ie. var(---widget-color) ). To be perfectly clear about Themes colors, each Theme has 8 colors. Here is how they are used: var ( --widget-color-0 ); // Project background color , if not overriden with the color picker in the \"Dashboard Panel\" left sidebar panel var ( --widget-color-1 ); // Text color , same as var ( --widget-color ) var ( --widget-color-2 ); // Primary color var ( --widget-color-3 ); // Active color , derivated from the primary color var ( --widget-color-4 ); // Hove color , derivated from the primary color var ( --widget-color-5 ); // Accent color , used for charts var ( --widget-color-6 ); // Accent color , used for charts var ( --widget-color-7 ); // Accent color , used for charts Theses colors can not be overriden globally. For Plotly charts types Line, Bars and Pie, they can be overriden in the widget \"Graphical Properties\" right side bar, for each chart individually .","title":"Plotly"},{"location":"wdg/plot-themes/#echarts","text":"eCharts widgets needs an \"option\" datanodes to be functionnal. Inside this datanode, the user can add datas and a lots of parameters like colors. By default, the color key inside the option object is not defined, we automatically apply colors to match the current project theme like so: var option = { \"color\" : [ \"var(--widget-color-2)\" , \"var(--widget-color-5)\" , \"var(--widget-color-6)\" , \"var(--widget-color-7)\" ] }; return option ;","title":"eCharts"},{"location":"wdg/wdg-annotation-video/","text":"Annotation & Video \u00b6 This group includes widgets for graphically annotating the dashboard. Label \u00b6 Label widget allows the user to write multiline text, and apply common widget formatting options if necessary. Image \u00b6 Image widget allows the user to annotate the dashboard by importing jpg or png images. When the enableActuator parameter is set to true , an actuator named base64Image appears in the \"Data Connection\" tab. It allows to display a base64 string encoded image. Animations may be achieved through dataNodes programming. See example below. Example : base64-image-py.xprjson base64-image-js.xprjson By default, keepRatio parameter is true . When set to false, the image ratio is no longer preserved and the image will inherit its container size. The hideImageURL parameter controls the display of the image selection URL in the widget. When an Image widget is dropped on the dashbard, this parameter is set by default to true and allows the selection of an image. When an image has been selected, the parameter is automatically set to false to avoid any display issues. If another image has be selected, this parameter must be manually set to true to re-enable the image selection. Markdown \u00b6 Markdown widget accept a markdown description in the form of string. Example: markdown-py.xprjson markdown-js.xprjson HTML \u00b6 HTML widget accepts a HTML document description in the form of string. Example : generic-html-py.xprjson generic-html-js.xprjson Camera \u00b6 The main purpose of this widget is to use the device's camera. The widget must be connected to a variable -type dataNode and will write information to its base64Image , mimeType and imageData actuators. Example : video-screenshot.xprjson","title":"Annotation & Video"},{"location":"wdg/wdg-annotation-video/#annotation-video","text":"This group includes widgets for graphically annotating the dashboard.","title":"Annotation &amp; Video"},{"location":"wdg/wdg-annotation-video/#label","text":"Label widget allows the user to write multiline text, and apply common widget formatting options if necessary.","title":"Label"},{"location":"wdg/wdg-annotation-video/#image","text":"Image widget allows the user to annotate the dashboard by importing jpg or png images. When the enableActuator parameter is set to true , an actuator named base64Image appears in the \"Data Connection\" tab. It allows to display a base64 string encoded image. Animations may be achieved through dataNodes programming. See example below. Example : base64-image-py.xprjson base64-image-js.xprjson By default, keepRatio parameter is true . When set to false, the image ratio is no longer preserved and the image will inherit its container size. The hideImageURL parameter controls the display of the image selection URL in the widget. When an Image widget is dropped on the dashbard, this parameter is set by default to true and allows the selection of an image. When an image has been selected, the parameter is automatically set to false to avoid any display issues. If another image has be selected, this parameter must be manually set to true to re-enable the image selection.","title":"Image"},{"location":"wdg/wdg-annotation-video/#markdown","text":"Markdown widget accept a markdown description in the form of string. Example: markdown-py.xprjson markdown-js.xprjson","title":"Markdown"},{"location":"wdg/wdg-annotation-video/#html","text":"HTML widget accepts a HTML document description in the form of string. Example : generic-html-py.xprjson generic-html-js.xprjson","title":"HTML"},{"location":"wdg/wdg-annotation-video/#camera","text":"The main purpose of this widget is to use the device's camera. The widget must be connected to a variable -type dataNode and will write information to its base64Image , mimeType and imageData actuators. Example : video-screenshot.xprjson","title":"Camera"},{"location":"wdg/wdg-basic-displays/","text":"Basic displays \u00b6 Basic widgets typically perform display of numeric values. Value display \u00b6 Value display is a generic display widget, which is intended to operate on primitive datatypes string and number. Among its parameters (in tab, \"Graphical Properties\") : decimalDigits : decimal precision of number. Default value is 3 KPI display \u00b6 Is card-like display. Real-time KPI display \u00b6 Like KPI display, but also provides a memory graph of past values. Examples : advanced-kpi-py.xprjson advanced-kpi-js.xprjson Status led \u00b6 For displaying binary status (on/off) Progress bar \u00b6 Enables to display a progress over a range. See example : progress-bar.xprjson Full-circular, semi-circular or arch-circular gauges \u00b6 Are adapted for displaying score values, that have a well defined min/max range. The other widgets are adapted for real-time display: Status led : for displaying binary status (on/off) More advance displays (like Label , Markdown or HTML ) can be found in the [Annotation & Video] category.","title":"Basic displays"},{"location":"wdg/wdg-basic-displays/#basic-displays","text":"Basic widgets typically perform display of numeric values.","title":"Basic displays"},{"location":"wdg/wdg-basic-displays/#value-display","text":"Value display is a generic display widget, which is intended to operate on primitive datatypes string and number. Among its parameters (in tab, \"Graphical Properties\") : decimalDigits : decimal precision of number. Default value is 3","title":"Value display"},{"location":"wdg/wdg-basic-displays/#kpi-display","text":"Is card-like display.","title":"KPI display"},{"location":"wdg/wdg-basic-displays/#real-time-kpi-display","text":"Like KPI display, but also provides a memory graph of past values. Examples : advanced-kpi-py.xprjson advanced-kpi-js.xprjson","title":"Real-time KPI display"},{"location":"wdg/wdg-basic-displays/#status-led","text":"For displaying binary status (on/off)","title":"Status led"},{"location":"wdg/wdg-basic-displays/#progress-bar","text":"Enables to display a progress over a range. See example : progress-bar.xprjson","title":"Progress bar"},{"location":"wdg/wdg-basic-displays/#full-circular-semi-circular-or-arch-circular-gauges","text":"Are adapted for displaying score values, that have a well defined min/max range. The other widgets are adapted for real-time display: Status led : for displaying binary status (on/off) More advance displays (like Label , Markdown or HTML ) can be found in the [Annotation & Video] category.","title":"Full-circular, semi-circular or arch-circular gauges"},{"location":"wdg/wdg-basic-inputs/","text":"Basic inputs and controls \u00b6 Basic inputs and controls widgets allow the dashboard end-user to set numeric values (such as Horizontal slider or Numeric input widgets), binary values (such as Checkbox or Switch widgets) or text values (such as Text input widget). More complex ones operate on lists or arrays (like select or list ). Some examples are illustrated below. All these widgets can only be connected to a dataNode-types with setValue from widget or setValue from file capabilities. Numeric input \u00b6 Numeric input is a numeric input widget, which is intended to operate on the primitive datatype number . Among its parameters (in tab, \"Graphical Properties\") : validationButton : adds a validation button to the right of the widget. When the validation button is clicked, the widget content is written to the connected dataNode. validationOnFocusOut : when focus is lost, widget content is written to the connected dataNode. The default value is true . isPassword : hides edited text as a password decimalDigits : decimal precision of number. Default value is 3 Text input \u00b6 text input is a text input widget, which is intended to operate on the primitive datatype number . Among its parameters (in tab, \"Graphical Properties\") : validationButton : adds a validation button to the right of the widget. When the validation button is clicked, the widget content is written to the connected dataNode. validationOnFocusOut : when focus is lost, widget content is written to the connected dataNode. The default value is true . isPassword : hides edited text as a password Horizontal slider \u00b6 Horizontal slider allows to set the value of a dataNode field of primitive datatype \"number\", between its min and max parameters. The step parameter controls the slider increment value. Vertical slider \u00b6 Similar to the Horizontal slider above with a different orientation. Double slider \u00b6 This slider has two handles, allowing to set both a minValue and a maxValue ranging between the values of minRange and maxRange parameters. When rangeActuator parameter is set to true , new minRange and maxRange actuators appear in the \"Data connection\" tab, enabling to set these actuators from other dataNodes. Checkbox \u00b6 Checkbox widget allows to set the value of a boolean dataNode field. Switch \u00b6 Similar to Checkbox Simple switch \u00b6 Allows to set discrete values. Push button \u00b6 Push button widget has two different behaviors, depending on its fileInput parameter (located in \"Graphical Properties\" tab). If fileInput is false, the button works as a trigger for connected dataNode (i.e. when the user clicks the button, dataNode execution is forced) If fileInput is true, the button works as file reader. When the user selects a file, its content is copied to: Variable CSV file reader CSV file player Generic file reader Examples : First, create a sample file Input.json with the following content { \"length\" : 25 , \"width\" : 10 } Then run buttons.xprjson Select \u00b6 Select widget has three actuators: keys : an array describing the options that can be selected. values : an array describing the corresponding values that can be written. This actuator is optional. selectedValue : the dataNode where the selected output will be written, the selected key or its corresponding value , if an array of values has been specified. With the following array of keys [ \"choice1\" , \"choice2\" ] and an (optional) array of values that the widget will output to the selectedValue actuator when the corresponding option is selected [ 1 , 2 ] If values actuator is not specifed, the selectedValue will contain the value of the item selected in the keys array. Otherwise, the selectedValue will contain the item from the values array corresponding to the selected key. combo-box-py.xprjson combo-box-js.xprjson List \u00b6 List widget expects a JavaScript array as its value input, such as : [ \"one\" , \"two\" , \"three\" ] selectedValue specifies the data source that will contain the selected item from the list. Example : list-py.xprjson list-js.xprjson Multi-select \u00b6 Example : multi-select-py.xprjson multi-select-js.xprjson Table \u00b6 Table widget expects its value input to reference a JavaScript array, containing subarrays, all of the same dimension, such as : [ [ \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" ], [ 5 , 6 , 9 , 11 , 15 , 16 , 20 , 20 , 16 , 12 , 7 , 5 ] ] This array will be displayed as : Example : table.xprjson Table may be editable if it is connected to a variable -type dataNode. Editable property can be set in a column-basis using the parameter editableCols . For example, if editableCols equals [0,1,2], columns 0, 1 and 2 are editable (i.e. cells in these columns, excluding headers, can be modified). The modifications will be assigned to the connected variable -type dataNode. Tables and editable tables may also be two dimentional. Examples : table-editable.xprjson editable-table-2D.xprjson","title":"Basic inputs"},{"location":"wdg/wdg-basic-inputs/#basic-inputs-and-controls","text":"Basic inputs and controls widgets allow the dashboard end-user to set numeric values (such as Horizontal slider or Numeric input widgets), binary values (such as Checkbox or Switch widgets) or text values (such as Text input widget). More complex ones operate on lists or arrays (like select or list ). Some examples are illustrated below. All these widgets can only be connected to a dataNode-types with setValue from widget or setValue from file capabilities.","title":"Basic inputs and controls"},{"location":"wdg/wdg-basic-inputs/#numeric-input","text":"Numeric input is a numeric input widget, which is intended to operate on the primitive datatype number . Among its parameters (in tab, \"Graphical Properties\") : validationButton : adds a validation button to the right of the widget. When the validation button is clicked, the widget content is written to the connected dataNode. validationOnFocusOut : when focus is lost, widget content is written to the connected dataNode. The default value is true . isPassword : hides edited text as a password decimalDigits : decimal precision of number. Default value is 3","title":"Numeric input"},{"location":"wdg/wdg-basic-inputs/#text-input","text":"text input is a text input widget, which is intended to operate on the primitive datatype number . Among its parameters (in tab, \"Graphical Properties\") : validationButton : adds a validation button to the right of the widget. When the validation button is clicked, the widget content is written to the connected dataNode. validationOnFocusOut : when focus is lost, widget content is written to the connected dataNode. The default value is true . isPassword : hides edited text as a password","title":"Text input"},{"location":"wdg/wdg-basic-inputs/#horizontal-slider","text":"Horizontal slider allows to set the value of a dataNode field of primitive datatype \"number\", between its min and max parameters. The step parameter controls the slider increment value.","title":"Horizontal slider"},{"location":"wdg/wdg-basic-inputs/#vertical-slider","text":"Similar to the Horizontal slider above with a different orientation.","title":"Vertical slider"},{"location":"wdg/wdg-basic-inputs/#double-slider","text":"This slider has two handles, allowing to set both a minValue and a maxValue ranging between the values of minRange and maxRange parameters. When rangeActuator parameter is set to true , new minRange and maxRange actuators appear in the \"Data connection\" tab, enabling to set these actuators from other dataNodes.","title":"Double slider"},{"location":"wdg/wdg-basic-inputs/#checkbox","text":"Checkbox widget allows to set the value of a boolean dataNode field.","title":"Checkbox"},{"location":"wdg/wdg-basic-inputs/#switch","text":"Similar to Checkbox","title":"Switch"},{"location":"wdg/wdg-basic-inputs/#simple-switch","text":"Allows to set discrete values.","title":"Simple switch"},{"location":"wdg/wdg-basic-inputs/#push-button","text":"Push button widget has two different behaviors, depending on its fileInput parameter (located in \"Graphical Properties\" tab). If fileInput is false, the button works as a trigger for connected dataNode (i.e. when the user clicks the button, dataNode execution is forced) If fileInput is true, the button works as file reader. When the user selects a file, its content is copied to: Variable CSV file reader CSV file player Generic file reader Examples : First, create a sample file Input.json with the following content { \"length\" : 25 , \"width\" : 10 } Then run buttons.xprjson","title":"Push button"},{"location":"wdg/wdg-basic-inputs/#select","text":"Select widget has three actuators: keys : an array describing the options that can be selected. values : an array describing the corresponding values that can be written. This actuator is optional. selectedValue : the dataNode where the selected output will be written, the selected key or its corresponding value , if an array of values has been specified. With the following array of keys [ \"choice1\" , \"choice2\" ] and an (optional) array of values that the widget will output to the selectedValue actuator when the corresponding option is selected [ 1 , 2 ] If values actuator is not specifed, the selectedValue will contain the value of the item selected in the keys array. Otherwise, the selectedValue will contain the item from the values array corresponding to the selected key. combo-box-py.xprjson combo-box-js.xprjson","title":"Select"},{"location":"wdg/wdg-basic-inputs/#list","text":"List widget expects a JavaScript array as its value input, such as : [ \"one\" , \"two\" , \"three\" ] selectedValue specifies the data source that will contain the selected item from the list. Example : list-py.xprjson list-js.xprjson","title":"List"},{"location":"wdg/wdg-basic-inputs/#multi-select","text":"Example : multi-select-py.xprjson multi-select-js.xprjson","title":"Multi-select"},{"location":"wdg/wdg-basic-inputs/#table","text":"Table widget expects its value input to reference a JavaScript array, containing subarrays, all of the same dimension, such as : [ [ \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" ], [ 5 , 6 , 9 , 11 , 15 , 16 , 20 , 20 , 16 , 12 , 7 , 5 ] ] This array will be displayed as : Example : table.xprjson Table may be editable if it is connected to a variable -type dataNode. Editable property can be set in a column-basis using the parameter editableCols . For example, if editableCols equals [0,1,2], columns 0, 1 and 2 are editable (i.e. cells in these columns, excluding headers, can be modified). The modifications will be assigned to the connected variable -type dataNode. Tables and editable tables may also be two dimentional. Examples : table-editable.xprjson editable-table-2D.xprjson","title":"Table"},{"location":"wdg/wdg-common-concept/","text":"Common concepts \u00b6 Widgets are dropped in the Widgets main tabset to the dashboard edition zone. A simple click on the top-right widget's pencil will open its parameterization sidebar. This form is divided into three tabs: Data connection and Graphical properties and Aspect .","title":"Common concepts"},{"location":"wdg/wdg-common-concept/#common-concepts","text":"Widgets are dropped in the Widgets main tabset to the dashboard edition zone. A simple click on the top-right widget's pencil will open its parameterization sidebar. This form is divided into three tabs: Data connection and Graphical properties and Aspect .","title":"Common concepts"},{"location":"wdg/wdg-geo-time/","text":"Geo & Time \u00b6 This category includes widgets related to location, date and time. Leaflet maps \u00b6 Leaflet maps widget has rich and versatile features for displaying various information on maps. It also has selection and interaction features. It is based on Leaflet library and its various plugins. When a new Leaflet maps widget is added to the dashboard, only one actuator named geoJSON1 is available in the \"Data connection\" tab. But this widget allows up to 5 types of display layers, according to the value of the associated parameter numberOfLayers . This parameter can be set in the \"Graphical properties\" tab as shown in the following picture: Depending on the parametrization, new actuators may appear in \"Data connection\" tab and offer : 0 to 8 possible layers of GeoJSON objects. Writing GeoJSON objects is described here . 0 to 8 possible layers of heatMap objects 0 to 8 possible layers of lineHeatMap objects 0 to 8 possible layers of choropleth objects 0 to 8 possible layer of imageOverlay objects 0 to 8 possible layer of svgOverlay objects In addition to these pure display layers, selection controls can be activated by enabling the drawingFeatures option. Regions of the map can thus be selected using the mouse. When this option is enabled, the selectedGeoJson actuator receives user selection as geoJson, and needs to be connected to a variable -type dataNode. This features are based on the Geoman plugin. Enabling the drawingFeatures option enables the drawingFeaturesOptions parameters set which manages selection options (point, line, polygone, rectangle). Other parameters : offlineSupport : displays controls on the maps that allow to store tiles for the current displayed geographic area. Useful when using the map offline (i.e. with no Internet connection) tileServer : currently there is support for MapboxStreets and HereHybridDay geoJson layers \u00b6 geoJson1 to geoJson8 inputs expect a geoJson object. Basic examples are shown below. Point \u00b6 Single point on a single layer of the map { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.295 , 48.8738 ] }, \"properties\" : { \"html\" : \"See <a href=\\\"https://en.wikipedia.org/wiki/Place_Charles_de_Gaulle\\\" target=\\\"_blank\\\">Place Charles de Gaulle</a>\" , \"awesomeMarker\" : { \"icon\" : \"fa-asterisk\" , \"prefix\" : \"fa\" , \"markerColor\" : \"red\" } } } ], \"properties\" : { \"description\" : \"Arc de triomphe\" , \"disableAutoscale\" : false } } which will be displayed as : Properties field of each feature allows to configure it. It comprises the following items : html : allows to write html call to be rendered inside the popup. awesomeMarker : JSON configuration object for the Leaflet.awesome-markers library, allowing colorful iconic & retina-proof markers for Leaflet, based on the Glyphicons / Font-Awesome icons. Only Font-Awesome icons are supported with xDash. Property Description Default Value Possible values icon Name of the icon 'home' See glyphicons or font-awesome prefix Select the icon library 'glyphicon' 'fa' for font-awesome or 'glyphicon' for bootstrap 3 markerColor Color of the marker 'blue' 'red', 'darkred', 'orange', 'green', 'darkgreen', 'blue', 'purple', 'darkpurple', 'cadetblue' iconColor Color of the icon 'white' 'white', 'black' or css code (hex, rgba etc) spin Make the icon spin false true or false. Font-awesome required extraClasses Additional classes in the created tag '' 'fa-rotate90 myclass' eller other custom configuration Examples : Single point : osm-geojson-point.xprjson Multiple points : osm-geojson-points.xprjson Awesome markers : osm-geojson-point-awesome-marker.xprjson Disable autoscale with geoJSON point : osm-geojson-point-disable-autoscale.xprjson Line \u00b6 Single line on a single layer of the map { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"LineString\" , \"coordinates\" : [ [ 2.295 , 48.8738 ], [ 2.321125 , 48.865487 ] ] }, \"properties\" : { \"style\" : { \"color\" : \"#FF0000\" , \"weight\" : 4 , \"opacity\" : 1 } } } ], \"properties\" : { \"description\" : \"<span style=\\\"color: #FF0000\\\">Champs-\u00c9lys\u00e9es</span>\" } } which will be displayed as : Examples : Single line : osm-geojson-line.xprjson Multiple lines : osm-geojson-lines.xprjson Polygon \u00b6 A polygon on a single layer of the map { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 2.300815 , 48.871943 ], [ 2.30158 , 48.864638 ], [ 2.310094 , 48.868996 ] ] ] }, \"properties\" : { \"style\" : { \"color\" : \"#01DF01\" , \"weight\" : 4 , \"opacity\" : 0.9 , \"fillColor\" : \"#01DF01\" , \"fillOpacity\" : 0.4 } } } ], \"properties\" : { \"description\" : \"<span style=\\\"color: #01DF01\\\">Triangle d'or</span>\" } } which will be displayed as : Example : osm-geojson-polygon.xprjson See also : Using GeoJSON with Leaflet heatMap layers \u00b6 heatMap1 to heatMap8 inputs expect a JSON object like the following one : { \"data\" : [ { \"lat\" : 44.78857833333333 , \"lng\" : 0.20539333333333332 , \"H2O\" : 58.0183 }, { \"lat\" : 44.78858 , \"lng\" : 0.20539333333333332 , \"H2O\" : 58.0187 } ], \"config\" : { \"opacity\" : 0.5 , \"radius\" : 1 , \"disableAutoscale\" : false , \"min\" : 0 , \"max\" : 100 , \"colorScale\" : \"interpolateSpectral\" , \"reverseColorScale\" : true } } When min and/or max config parameters are not specified, they are automatically computed from the data set. colorScale is a string from interpolate-type colorscales of D3.js : https://github.com/d3/d3-scale-chromatic . Example of display (for a larger data set) : Example : osm-heatmap-view.xprjson Several parameters control the display of the heatmap, in particular : sampledDisplay : allows to feed the map in real-time with instantaneous measures (single heatmap point). The config of the first point will be used. See corresponding examples: osm-heatmap-play-py.xprjson osm-heatmap-play-js.xprjson lineHeatMap layers \u00b6 lineHeatMap1 to lineHeatMap8 inputs expect a JSON object like the following one : { \"data\" : [ { \"coordinates\" : [ [ 4.84112 , 45.74968 ], [ 4.84091 , 45.74981 ] ], \"CO2\" : 6 }, { \"coordinates\" : [ [ 4.84138 , 45.74953 ], [ 4.84112 , 45.74968 ] ], \"CO2\" : 10 } ], \"config\" : { \"opacity\" : 0.9 , \"weight\" : 4 , \"disableAutoscale\" : false , \"min\" : 0 , \"max\" : 10 , \"colorScale\" : \"interpolateSpectral\" , \"reverseColorScale\" : true } } When min and/or max config parameters are not specified, they are automatically computed from the data set. colorScale is a string from interpolate-type colorscales of D3.js : https://github.com/d3/d3-scale-chromatic . Example of display (for a larger data set) : Example : osm-lineheatmap.xprjson Choropleth layers \u00b6 choropleth1 to choropleth8 inputs expect a JSON object like the following one : { \"data\" : [ { \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 2.329144745999656 , 48.87299590267482 ], [ 2.329453736347205 , 48.8723745764414 ], [ 2.331221849053691 , 48.8721034501072 ] ] ] }, \"CO2\" : 6 }, { \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 2.331445008712763 , 48.87264570173727 ], [ 2.332766800791433 , 48.870849470245 ], [ 2.3349983986918237 , 48.87142562719721 ] ] ] }, \"CO2\" : 10 } ], \"config\" : { \"opacity\" : 0.9 , \"weight\" : 4 , \"disableAutoscale\" : false , \"min\" : 0 , \"max\" : 10 , \"colorScale\" : \"interpolateOranges\" , \"reverseColorScale\" : false } } When min and/or max config parameters are not specified, they are automatically computed from the data set. colorScale is a string from interpolate-type colorscales of D3.js : https://github.com/d3/d3-scale-chromatic . Example of display (for a larger data set) : Example : osm-choropleth-py.xprjson osm-choropleth-js.xprjson imageOverlay layers \u00b6 imageOverlay1 to imageOverlay8 inputs expect a geoJson object like the following one : { \"imageUrl\" = \"http://www.fondation-tuck.fr/upload/docs/image/jpeg/2015-01/logo-ifpen.jpg\" ; \"imageBounds\" = [ [ 48.874875 , 2.171738 ], [ 48.877923 , 2.179484 ] ]; \"title\" = \"IFPEN location\" ; \"addAs\" = \"overlay\" ; // overlay or baseLayer } As shown in the code snippet above, the addAs parameter may take two values: overlay which adds a checkbox control, or baseLayer which adds a radio button control. Example : osm-image-overlay.xprjson svgOverlay layers \u00b6 svgOverlay1 to svgOverlay8 inputs expect a JSON object like the following one : { \"data\" : [ { \"lat\" : 48.876684999999995 , \"lng\" : 2.175765 , \"rotation\" : 255 }, { \"lat\" : 48.876684999999995 , \"lng\" : 2.175765 , \"rotation\" : 256 } ], \"config\" : { \"marker\" : \"arrow\" , \"title\" : \"Wind direction\" , \"opacity\" : 0.5 , \"length\" : 9.3 , \"disableAutoscale\" : false , \"addAs\" : \"overlay\" // overlay or baseLayer } } Example of display (for a larger data set) : Example : osm-svg-layer-view-js.xprjson Drawing features \u00b6 It is possible to allow the user to manually select points, lines, rectangles or polygone regions in the map. This is possible by enable the drawingFeatures option. Selection result will be written to the selectedGeoJson actuator. Example : osm-drawing-features.xprjson Folium Maps \u00b6 Folium is a Python library used for visualizing geospatial data. It leverages the power of the Leaflet.js library and provides a simple way to create interactive maps. Folium can be used to create various types of maps such as choropleth maps, bubble maps, and scatter maps, and provides an easy-to-use interface for adding markers, popups, and other interactive features to the maps. Folium is built on top of the Python data analysis library pandas, which makes it easy to manipulate and visualize large datasets. It also supports several tilesets such as OpenStreetMap, Mapbox, and Stamen, which can be used to customize the look and feel of the maps. Usage examples: folium-point.xprjson Address autocompletion \u00b6 This widget uses the here geocoder autocomplete API to provide suggestion as the user types an address location. The parameter countryIsoCodes restricts the provided suggestions to the specifed country. Simple calendar \u00b6 Use the Simple calendar widget to select a date. Example : date-picker.xprjson Date-range calendar \u00b6 Enables the selection of a date interval. D3 year heatmap caldendar \u00b6 Allows to associate range heatmap to a yearly-based calendar. Very useful to visually identify sporadic information. Date selection is also possible. Example : d3-year-heatmap-calendar.xprjson Simple clock \u00b6 Use the Simple clock widget to select a time. Example : time-picker.xprjson","title":"Geo & Time"},{"location":"wdg/wdg-geo-time/#geo-time","text":"This category includes widgets related to location, date and time.","title":"Geo &amp; Time"},{"location":"wdg/wdg-geo-time/#leaflet-maps","text":"Leaflet maps widget has rich and versatile features for displaying various information on maps. It also has selection and interaction features. It is based on Leaflet library and its various plugins. When a new Leaflet maps widget is added to the dashboard, only one actuator named geoJSON1 is available in the \"Data connection\" tab. But this widget allows up to 5 types of display layers, according to the value of the associated parameter numberOfLayers . This parameter can be set in the \"Graphical properties\" tab as shown in the following picture: Depending on the parametrization, new actuators may appear in \"Data connection\" tab and offer : 0 to 8 possible layers of GeoJSON objects. Writing GeoJSON objects is described here . 0 to 8 possible layers of heatMap objects 0 to 8 possible layers of lineHeatMap objects 0 to 8 possible layers of choropleth objects 0 to 8 possible layer of imageOverlay objects 0 to 8 possible layer of svgOverlay objects In addition to these pure display layers, selection controls can be activated by enabling the drawingFeatures option. Regions of the map can thus be selected using the mouse. When this option is enabled, the selectedGeoJson actuator receives user selection as geoJson, and needs to be connected to a variable -type dataNode. This features are based on the Geoman plugin. Enabling the drawingFeatures option enables the drawingFeaturesOptions parameters set which manages selection options (point, line, polygone, rectangle). Other parameters : offlineSupport : displays controls on the maps that allow to store tiles for the current displayed geographic area. Useful when using the map offline (i.e. with no Internet connection) tileServer : currently there is support for MapboxStreets and HereHybridDay","title":"Leaflet maps"},{"location":"wdg/wdg-geo-time/#geojson-layers","text":"geoJson1 to geoJson8 inputs expect a geoJson object. Basic examples are shown below.","title":"geoJson layers"},{"location":"wdg/wdg-geo-time/#point","text":"Single point on a single layer of the map { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Point\" , \"coordinates\" : [ 2.295 , 48.8738 ] }, \"properties\" : { \"html\" : \"See <a href=\\\"https://en.wikipedia.org/wiki/Place_Charles_de_Gaulle\\\" target=\\\"_blank\\\">Place Charles de Gaulle</a>\" , \"awesomeMarker\" : { \"icon\" : \"fa-asterisk\" , \"prefix\" : \"fa\" , \"markerColor\" : \"red\" } } } ], \"properties\" : { \"description\" : \"Arc de triomphe\" , \"disableAutoscale\" : false } } which will be displayed as : Properties field of each feature allows to configure it. It comprises the following items : html : allows to write html call to be rendered inside the popup. awesomeMarker : JSON configuration object for the Leaflet.awesome-markers library, allowing colorful iconic & retina-proof markers for Leaflet, based on the Glyphicons / Font-Awesome icons. Only Font-Awesome icons are supported with xDash. Property Description Default Value Possible values icon Name of the icon 'home' See glyphicons or font-awesome prefix Select the icon library 'glyphicon' 'fa' for font-awesome or 'glyphicon' for bootstrap 3 markerColor Color of the marker 'blue' 'red', 'darkred', 'orange', 'green', 'darkgreen', 'blue', 'purple', 'darkpurple', 'cadetblue' iconColor Color of the icon 'white' 'white', 'black' or css code (hex, rgba etc) spin Make the icon spin false true or false. Font-awesome required extraClasses Additional classes in the created tag '' 'fa-rotate90 myclass' eller other custom configuration Examples : Single point : osm-geojson-point.xprjson Multiple points : osm-geojson-points.xprjson Awesome markers : osm-geojson-point-awesome-marker.xprjson Disable autoscale with geoJSON point : osm-geojson-point-disable-autoscale.xprjson","title":"Point"},{"location":"wdg/wdg-geo-time/#line","text":"Single line on a single layer of the map { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"LineString\" , \"coordinates\" : [ [ 2.295 , 48.8738 ], [ 2.321125 , 48.865487 ] ] }, \"properties\" : { \"style\" : { \"color\" : \"#FF0000\" , \"weight\" : 4 , \"opacity\" : 1 } } } ], \"properties\" : { \"description\" : \"<span style=\\\"color: #FF0000\\\">Champs-\u00c9lys\u00e9es</span>\" } } which will be displayed as : Examples : Single line : osm-geojson-line.xprjson Multiple lines : osm-geojson-lines.xprjson","title":"Line"},{"location":"wdg/wdg-geo-time/#polygon","text":"A polygon on a single layer of the map { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 2.300815 , 48.871943 ], [ 2.30158 , 48.864638 ], [ 2.310094 , 48.868996 ] ] ] }, \"properties\" : { \"style\" : { \"color\" : \"#01DF01\" , \"weight\" : 4 , \"opacity\" : 0.9 , \"fillColor\" : \"#01DF01\" , \"fillOpacity\" : 0.4 } } } ], \"properties\" : { \"description\" : \"<span style=\\\"color: #01DF01\\\">Triangle d'or</span>\" } } which will be displayed as : Example : osm-geojson-polygon.xprjson See also : Using GeoJSON with Leaflet","title":"Polygon"},{"location":"wdg/wdg-geo-time/#heatmap-layers","text":"heatMap1 to heatMap8 inputs expect a JSON object like the following one : { \"data\" : [ { \"lat\" : 44.78857833333333 , \"lng\" : 0.20539333333333332 , \"H2O\" : 58.0183 }, { \"lat\" : 44.78858 , \"lng\" : 0.20539333333333332 , \"H2O\" : 58.0187 } ], \"config\" : { \"opacity\" : 0.5 , \"radius\" : 1 , \"disableAutoscale\" : false , \"min\" : 0 , \"max\" : 100 , \"colorScale\" : \"interpolateSpectral\" , \"reverseColorScale\" : true } } When min and/or max config parameters are not specified, they are automatically computed from the data set. colorScale is a string from interpolate-type colorscales of D3.js : https://github.com/d3/d3-scale-chromatic . Example of display (for a larger data set) : Example : osm-heatmap-view.xprjson Several parameters control the display of the heatmap, in particular : sampledDisplay : allows to feed the map in real-time with instantaneous measures (single heatmap point). The config of the first point will be used. See corresponding examples: osm-heatmap-play-py.xprjson osm-heatmap-play-js.xprjson","title":"heatMap layers"},{"location":"wdg/wdg-geo-time/#lineheatmap-layers","text":"lineHeatMap1 to lineHeatMap8 inputs expect a JSON object like the following one : { \"data\" : [ { \"coordinates\" : [ [ 4.84112 , 45.74968 ], [ 4.84091 , 45.74981 ] ], \"CO2\" : 6 }, { \"coordinates\" : [ [ 4.84138 , 45.74953 ], [ 4.84112 , 45.74968 ] ], \"CO2\" : 10 } ], \"config\" : { \"opacity\" : 0.9 , \"weight\" : 4 , \"disableAutoscale\" : false , \"min\" : 0 , \"max\" : 10 , \"colorScale\" : \"interpolateSpectral\" , \"reverseColorScale\" : true } } When min and/or max config parameters are not specified, they are automatically computed from the data set. colorScale is a string from interpolate-type colorscales of D3.js : https://github.com/d3/d3-scale-chromatic . Example of display (for a larger data set) : Example : osm-lineheatmap.xprjson","title":"lineHeatMap layers"},{"location":"wdg/wdg-geo-time/#choropleth-layers","text":"choropleth1 to choropleth8 inputs expect a JSON object like the following one : { \"data\" : [ { \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 2.329144745999656 , 48.87299590267482 ], [ 2.329453736347205 , 48.8723745764414 ], [ 2.331221849053691 , 48.8721034501072 ] ] ] }, \"CO2\" : 6 }, { \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 2.331445008712763 , 48.87264570173727 ], [ 2.332766800791433 , 48.870849470245 ], [ 2.3349983986918237 , 48.87142562719721 ] ] ] }, \"CO2\" : 10 } ], \"config\" : { \"opacity\" : 0.9 , \"weight\" : 4 , \"disableAutoscale\" : false , \"min\" : 0 , \"max\" : 10 , \"colorScale\" : \"interpolateOranges\" , \"reverseColorScale\" : false } } When min and/or max config parameters are not specified, they are automatically computed from the data set. colorScale is a string from interpolate-type colorscales of D3.js : https://github.com/d3/d3-scale-chromatic . Example of display (for a larger data set) : Example : osm-choropleth-py.xprjson osm-choropleth-js.xprjson","title":"Choropleth layers"},{"location":"wdg/wdg-geo-time/#imageoverlay-layers","text":"imageOverlay1 to imageOverlay8 inputs expect a geoJson object like the following one : { \"imageUrl\" = \"http://www.fondation-tuck.fr/upload/docs/image/jpeg/2015-01/logo-ifpen.jpg\" ; \"imageBounds\" = [ [ 48.874875 , 2.171738 ], [ 48.877923 , 2.179484 ] ]; \"title\" = \"IFPEN location\" ; \"addAs\" = \"overlay\" ; // overlay or baseLayer } As shown in the code snippet above, the addAs parameter may take two values: overlay which adds a checkbox control, or baseLayer which adds a radio button control. Example : osm-image-overlay.xprjson","title":"imageOverlay layers"},{"location":"wdg/wdg-geo-time/#svgoverlay-layers","text":"svgOverlay1 to svgOverlay8 inputs expect a JSON object like the following one : { \"data\" : [ { \"lat\" : 48.876684999999995 , \"lng\" : 2.175765 , \"rotation\" : 255 }, { \"lat\" : 48.876684999999995 , \"lng\" : 2.175765 , \"rotation\" : 256 } ], \"config\" : { \"marker\" : \"arrow\" , \"title\" : \"Wind direction\" , \"opacity\" : 0.5 , \"length\" : 9.3 , \"disableAutoscale\" : false , \"addAs\" : \"overlay\" // overlay or baseLayer } } Example of display (for a larger data set) : Example : osm-svg-layer-view-js.xprjson","title":"svgOverlay layers"},{"location":"wdg/wdg-geo-time/#drawing-features","text":"It is possible to allow the user to manually select points, lines, rectangles or polygone regions in the map. This is possible by enable the drawingFeatures option. Selection result will be written to the selectedGeoJson actuator. Example : osm-drawing-features.xprjson","title":"Drawing features"},{"location":"wdg/wdg-geo-time/#folium-maps","text":"Folium is a Python library used for visualizing geospatial data. It leverages the power of the Leaflet.js library and provides a simple way to create interactive maps. Folium can be used to create various types of maps such as choropleth maps, bubble maps, and scatter maps, and provides an easy-to-use interface for adding markers, popups, and other interactive features to the maps. Folium is built on top of the Python data analysis library pandas, which makes it easy to manipulate and visualize large datasets. It also supports several tilesets such as OpenStreetMap, Mapbox, and Stamen, which can be used to customize the look and feel of the maps. Usage examples: folium-point.xprjson","title":"Folium Maps"},{"location":"wdg/wdg-geo-time/#address-autocompletion","text":"This widget uses the here geocoder autocomplete API to provide suggestion as the user types an address location. The parameter countryIsoCodes restricts the provided suggestions to the specifed country.","title":"Address autocompletion"},{"location":"wdg/wdg-geo-time/#simple-calendar","text":"Use the Simple calendar widget to select a date. Example : date-picker.xprjson","title":"Simple calendar"},{"location":"wdg/wdg-geo-time/#date-range-calendar","text":"Enables the selection of a date interval.","title":"Date-range calendar"},{"location":"wdg/wdg-geo-time/#d3-year-heatmap-caldendar","text":"Allows to associate range heatmap to a yearly-based calendar. Very useful to visually identify sporadic information. Date selection is also possible. Example : d3-year-heatmap-calendar.xprjson","title":"D3 year heatmap caldendar"},{"location":"wdg/wdg-geo-time/#simple-clock","text":"Use the Simple clock widget to select a time. Example : time-picker.xprjson","title":"Simple clock"},{"location":"wdg/wdg-plots/","text":"Plots \u00b6 Plots in Chalk'it may be made either with Python or JavaScript code: Python-based plots are available using Plolty Python or Matplotlib , currenly only with the Python Script (Pyodide) -type dataNode JavaScript-based plots are available using Plotly.js , Apache ECharts or Vega Simplified usage (array actuators) is available for Plotly line , Plotly bar , Plotly pie and Plotly 3D surface . Otherwise, use the Plotly generic for a complete Plotly.js options and configurations Plotly.js-based widgets share common parameters, especially hideModeBar which allows to hide plot options toolbar at dashboard play. Plotly line \u00b6 Allows to quickly display line charts, when x and y axis are expressed as arrays of numbers. The parameter numberOfAxis allows to specifiy up to 8 y-axis actuators (named y1 to y8 ), sharing the same x-axis actuator (named x ). Widget layout may be configured in the \"Graphical properties\" tab. line-chart.xprjson Plotly bar \u00b6 Here parameter numberOfAxis allows to specify couples of x and y axis actuators (named x1 , y1 to x8 , y8 ). Some examples : bar-chart.xprjson stack-bar-chart-js.xprjson Plotly pie \u00b6 This widget has two actuators : values : an array of values to be displayed as pie chart labels : an optional array of labels associated to values Example : pie-chart.xprjson Plotly 3D surface \u00b6 This widget has three actuators : x : 1-D numeric array of size N y : 1-D numeric array of size M z : 2-D numeric array (an M -size array of N -size arrays) Example : 3d-surface.xprjson Plotly Real-time \u00b6 The widget provides a real-time graph for displaying numeric-based dataNode inputs, having a given sample-time. Example : real-time-kpi-plotly-js.xprjson Plotly JavaScript generic \u00b6 This widget accepts three actuators : data , layout and selection . In opposite to previous Plotly-based widgets, layout cannot be set from \"Graphical properties\" tab. This brings more expressive power for layout specification using programming dataNodes. Defining data and layout is illustrated in plotly.js documentation . Some examples: bubble-chart-js.xprjson plotly-stat-box-js.xprjson The selection actuator is detailed in this topic Plotly Python Generic \u00b6 This widget expects a Plotly figure Python object, produced by a Python Script (Pyodide) -type dataNode. Below a code example: import plotly.express as px df = px . data . gapminder () . query ( \"country=='Canada'\" ) fig = px . line ( df , x = \"year\" , y = \"lifeExp\" , title = 'Life expectancy in Canada' ) return fig All receipes may be found in Ploty Python documentation . No call to fig.show() is needed because rendering process will be entirely handled by Chalk'it according to its rendering rules. Example: plotly-density-heatmap-py.xprjson Matplotlib \u00b6 In the same way as Plotly Python widget, Matplotlib widget expect a figure object as actuator. Below a code example: import matplotlib.pyplot as plt fig , ax = plt . subplots () fruits = [ 'apple' , 'blueberry' , 'cherry' , 'orange' ] counts = [ 40 , 100 , 30 , 55 ] bar_labels = [ 'red' , 'blue' , '_red' , 'orange' ] bar_colors = [ 'tab:red' , 'tab:blue' , 'tab:red' , 'tab:orange' ] ax . bar ( fruits , counts , label = bar_labels , color = bar_colors ) ax . set_ylabel ( 'fruit supply' ) ax . set_title ( 'Fruit supply by kind and color' ) ax . legend ( title = 'Fruit color' ) return fig All receipes may be found in Matplotlib documentation . No call to plt.show() is needed because rendering process will be entirely handled by Chalk'it according to its rendering rules. Example: matplotlib-bar-color-py.xprjson Vega \u00b6 In the same spirit as Plotly generic widget above, you can visualize Vega specifications and connect them to data from other dataNodes. Browse Vega examples gallery . Copy and paste the appropriate visualization to a JavaScript Formula dataNode. Finally, connect this dataNode to the specification widget actuator. In this examples gallery, data is typically read from URL referenced sources using the Vega url keyword. You can connect to Chalk'it dataNodes using the Vega values keyword instead. Be aware when copying examples that URLS in these examples use relative paths. For proper execution on Chalk'it, the absolute data path needs to be used (e.g. use 'https://vega.github.io/vega/data/movies.json' instead of 'data/movies.json'). Some examples: vega-les-miserables-js.xprjson ECharts \u00b6 Simply, copy and paste the needed visualization from ECharts examples gallery to a JavaScript Script dataNode. This example shall return an option JSON according to ECharts grammar. Finally, connect this dataNode to the option widget actuator. Some examples: echarts-covid-comparison-js.xprjson","title":"Plots"},{"location":"wdg/wdg-plots/#plots","text":"Plots in Chalk'it may be made either with Python or JavaScript code: Python-based plots are available using Plolty Python or Matplotlib , currenly only with the Python Script (Pyodide) -type dataNode JavaScript-based plots are available using Plotly.js , Apache ECharts or Vega Simplified usage (array actuators) is available for Plotly line , Plotly bar , Plotly pie and Plotly 3D surface . Otherwise, use the Plotly generic for a complete Plotly.js options and configurations Plotly.js-based widgets share common parameters, especially hideModeBar which allows to hide plot options toolbar at dashboard play.","title":"Plots"},{"location":"wdg/wdg-plots/#plotly-line","text":"Allows to quickly display line charts, when x and y axis are expressed as arrays of numbers. The parameter numberOfAxis allows to specifiy up to 8 y-axis actuators (named y1 to y8 ), sharing the same x-axis actuator (named x ). Widget layout may be configured in the \"Graphical properties\" tab. line-chart.xprjson","title":"Plotly line"},{"location":"wdg/wdg-plots/#plotly-bar","text":"Here parameter numberOfAxis allows to specify couples of x and y axis actuators (named x1 , y1 to x8 , y8 ). Some examples : bar-chart.xprjson stack-bar-chart-js.xprjson","title":"Plotly bar"},{"location":"wdg/wdg-plots/#plotly-pie","text":"This widget has two actuators : values : an array of values to be displayed as pie chart labels : an optional array of labels associated to values Example : pie-chart.xprjson","title":"Plotly pie"},{"location":"wdg/wdg-plots/#plotly-3d-surface","text":"This widget has three actuators : x : 1-D numeric array of size N y : 1-D numeric array of size M z : 2-D numeric array (an M -size array of N -size arrays) Example : 3d-surface.xprjson","title":"Plotly 3D surface"},{"location":"wdg/wdg-plots/#plotly-real-time","text":"The widget provides a real-time graph for displaying numeric-based dataNode inputs, having a given sample-time. Example : real-time-kpi-plotly-js.xprjson","title":"Plotly Real-time"},{"location":"wdg/wdg-plots/#plotly-javascript-generic","text":"This widget accepts three actuators : data , layout and selection . In opposite to previous Plotly-based widgets, layout cannot be set from \"Graphical properties\" tab. This brings more expressive power for layout specification using programming dataNodes. Defining data and layout is illustrated in plotly.js documentation . Some examples: bubble-chart-js.xprjson plotly-stat-box-js.xprjson The selection actuator is detailed in this topic","title":"Plotly JavaScript generic"},{"location":"wdg/wdg-plots/#plotly-python-generic","text":"This widget expects a Plotly figure Python object, produced by a Python Script (Pyodide) -type dataNode. Below a code example: import plotly.express as px df = px . data . gapminder () . query ( \"country=='Canada'\" ) fig = px . line ( df , x = \"year\" , y = \"lifeExp\" , title = 'Life expectancy in Canada' ) return fig All receipes may be found in Ploty Python documentation . No call to fig.show() is needed because rendering process will be entirely handled by Chalk'it according to its rendering rules. Example: plotly-density-heatmap-py.xprjson","title":"Plotly Python Generic"},{"location":"wdg/wdg-plots/#matplotlib","text":"In the same way as Plotly Python widget, Matplotlib widget expect a figure object as actuator. Below a code example: import matplotlib.pyplot as plt fig , ax = plt . subplots () fruits = [ 'apple' , 'blueberry' , 'cherry' , 'orange' ] counts = [ 40 , 100 , 30 , 55 ] bar_labels = [ 'red' , 'blue' , '_red' , 'orange' ] bar_colors = [ 'tab:red' , 'tab:blue' , 'tab:red' , 'tab:orange' ] ax . bar ( fruits , counts , label = bar_labels , color = bar_colors ) ax . set_ylabel ( 'fruit supply' ) ax . set_title ( 'Fruit supply by kind and color' ) ax . legend ( title = 'Fruit color' ) return fig All receipes may be found in Matplotlib documentation . No call to plt.show() is needed because rendering process will be entirely handled by Chalk'it according to its rendering rules. Example: matplotlib-bar-color-py.xprjson","title":"Matplotlib"},{"location":"wdg/wdg-plots/#vega","text":"In the same spirit as Plotly generic widget above, you can visualize Vega specifications and connect them to data from other dataNodes. Browse Vega examples gallery . Copy and paste the appropriate visualization to a JavaScript Formula dataNode. Finally, connect this dataNode to the specification widget actuator. In this examples gallery, data is typically read from URL referenced sources using the Vega url keyword. You can connect to Chalk'it dataNodes using the Vega values keyword instead. Be aware when copying examples that URLS in these examples use relative paths. For proper execution on Chalk'it, the absolute data path needs to be used (e.g. use 'https://vega.github.io/vega/data/movies.json' instead of 'data/movies.json'). Some examples: vega-les-miserables-js.xprjson","title":"Vega"},{"location":"wdg/wdg-plots/#echarts","text":"Simply, copy and paste the needed visualization from ECharts examples gallery to a JavaScript Script dataNode. This example shall return an option JSON according to ECharts grammar. Finally, connect this dataNode to the option widget actuator. Some examples: echarts-covid-comparison-js.xprjson","title":"ECharts"},{"location":"wdg/wdg/","text":"Widgets \u00b6 Chalk'it offers WYSIWYG (what you see is what you get) edition capabilities. Dashboards are built using drag and drop of widgets, which are connected to dataNodes. Common concepts Basic Plots Geo & Time Annotation & Video","title":"Introduction"},{"location":"wdg/wdg/#widgets","text":"Chalk'it offers WYSIWYG (what you see is what you get) edition capabilities. Dashboards are built using drag and drop of widgets, which are connected to dataNodes. Common concepts Basic Plots Geo & Time Annotation & Video","title":"Widgets"},{"location":"wdg/selection/plot-selection/","text":"Select and Filter data \u00b6 Selection and Filter are important tools in interactive data analysis and visualisation. With Plotly JavaScript generic graph, the Chalk'it platform gives you access to selected events which contain all fields necessary in order to use selected element in the dataflow (transfer selection to another graph, filter data according to selection, ...) For those familiar with Plotly select events, \"appendix I\" will explain how xDash selection events are created. main data and global index \u00b6 When user wants to create a graph from a selection of another graph, or to transfer the selection from one graph to another (or from one graph to a script), there is a logic of a main shared data. This could be the result of a CSV import, a global JSON or GeoJSON. This shared data is considered and referenced as the global data in our exemples and will be present in the dataNode [data]. Each global shared data is indexed (In the CSV exemple, the index is the lane of each datum) and we will use the term \"global index\" as a generic expression to reference this main indexation. How to use the selection from a graph to draw another one \u00b6 First example : selection-example-1.xprjson In this first exemple we : Plot all data in one scatter plot graph (Plotly Generic) Recover the selection from the scatter Build an histogram using only the selected data The main data is an array of datum that each contains 3 values [Alpha, Beta, Delta]. Typically obtained from a CSV import. The cross plot will be done between [alpha vs beta] and [delta] will be used to draw the histogram. The dataFlow contains 5 dataNodes and 2 associated widgets One DataNode that contains the global data. Two DataNodes are created for each Plotly Graph (data and layout) One DataNode which contains the selection One widget [plotly generic] is the scatter plot One widget [plotly generic] is the histogram The data for the Plotly histogram is dependant of the selection DataNode. The graphs and DataNodes associated (PloltlyData and PlotlyLayout) dont know each others and dont have direct relationship. In order to have a clean change in the histogram, the X axis limit and bin limits are defined via all the data. How to draw a graph with different sources of selection \u00b6 Now, lets imagine that what you want to draw is defined by the addition of different incoming selections. Example 2: selection-example-2.xprjson In Exemple 2 We draw 2 scatter plots Both selection are used to draw the histogram. This exemple is similar than the last one except that : the selection datanode has now one field for each cross plot selection one dataNode is now present to process the selection [MultiSelectionProcess] The process node does the addition of each selection. The structure of the selection node has changed, there is now one field for each graph which will aggregate their selection. Each selection actuator from the cross plot now is now linked with one field of the selection node. It is relevant that the code of the process DataNode dont know the number and the origin of each incoming selections. You can so add and remove origin of selection without changing the code of the process datanode The PlotlyData datanode used for the histogram takes information from the process node. A datanode is used to collect information and create the \"global\" selection. This is not done in the datanode used for plotly data. This global selection could be used for other graphs or script without copy/paste. How to synchronize selection to have a single global selection \u00b6 The different selection on each graph are independant. In some case we want a \"global\" selection\" which regroup all selection and that all graph show the selected data. Example 3 selection-example-3.xprjson In this exemple we do 2 scatter plots from the same global data. As exemple 2, we use a process node to concatenate the information but on both graphs we want to see all the selected data. Plotly graphs are mainly correlated with their own selection. Trying to use the \"selectedpoints\" field present in plotly data is a bad idea. This fied is ok if the graph dont has his own selection behavior. But this field is erased when using \"rectangle\" or \"lasso\" selection. It is better to consider external selection as a complement of the possible present selection. \"appendix II\" will enter deeper in exposing the selection The additional selected items are not drawn last, so we see clearly a difference between the selection from the graph and the selection from other sources. In next exemple we propose a solution to handle this. How to use the selection event if the index selected are different from the data index \u00b6 Example 4: selection-example-4.xprjson For the moment, in the different exemples we have assumed that the [index] given by the selection is the same that the index of the data. It means that if the data selected is \"4\" it is the same index on the global data index. But it is not always the case, for multiple reasons, the index given by the selection could be different, for exemple you need to draw only a part of the data you need to sort the data X vs Y in order to draw a line you need to sort the global data before drawing in order to control the Z order of the draw ... Each plotly trace contains a [customdata] field that can help us to resolve this problem In exemple [nom de l'exemple] we used the same But in the data for plotly DataNode we order the drawn order with all selected data at the end. it is not possible to give a drawn order to plotly (V2.16.3). The element and the trace are drawn in the order given by the user. Last element of last trace are drawn last. In the data for plotly Datanode we sort the element but we keep the change in an array called \"orderForGraph\" which will be transfer to plotly in the \"customdata\" field. This field is present in the selection of the dataflow and can be used in the selectionProcess node to obtain the equivalent index. Create a reset selection action \u00b6 Example 5: selection-example-5.xprjson in our exemple, selection is in an independant DataNode, and no more only a graphical features. In order to reset the selection, we need to clean all the DataFlow and all the graphics. In exemple 5 we create a reset selection script which is triggered by a push button. 3 significant addition in the dataNode have to be done in order to have a clean result. Reset the DataNode [Selection] via the chalkit function chalkit.setVariable . This will reset the selection and the plotly data (done in [ResetSelection] dataNode) Add the field \"selections : []\" in all layout impacted in order to remove all the visible rectangle or lasso drawn Create a relation between the resetSelection action script and the different layout to trigger the layout dataNodes. Good Practices \u00b6 Create one datanode for the layout and one for the data \u00b6 If one dataNode is used to give the Data and the Layout for the widget, some unexpected graphical behavior can happen. Usually data often change according to action, but user like to keep element of visualisation (zoom, factor, element selected, ... ) When data changed, plotly will also reset the layout if they are in the same datanode, which can change your view according to what is defined in the original layout. Never use the same layout DataNode for multiple graphs. \u00b6 Plotly keeps in memory each layout for its own internal use. It never makes copy. If the same layout is used for exemple for 2 scatter plots each pan/zoom/selection done on one plot ... will be passed to the other graph but not at the same time. The repercution will be done next time plotly via the dataFlow needs to check the current layout. And you dont know when it will happens (often when the widget is selected) Appendix 1 : Plotly Selection and Chalk'it Selection \u00b6 Structures of the plotly selection are discribe in https://plotly.com/javascript/plotlyjs-events/#event-data So plotly selection events are dependant from the kind of the original graph (2D, 3D, map, ...) Plotly selection cannot directly be transformed in JSON because it is a circular structure. Chalk'it selection event is one unified selection containing an array for each trace which contains the index of the element and the metadata if those one were present in the original trace. [curveNumber (trace number)] indexSelected : [] customdata : [] (if customdata field is present in original DataTrace) For exemple if you have 2 traces in your Plotly graph, Chalk'it selection would return : [ 0 : {Data : [1, 10, 120, 123], customData: [1, 10, 120, 123]}] [ 1 : {Data : [1, 10, 120, 123], customData: [1, 10, 120, 123]}] Appendix 2 : how to handle all selection behaviors from plotly without creating trouble \u00b6 In some situation you want to have a total control of filter/selection and the way plotly control the selection can create confusion. The behavior you need can visualy enter in \"conflict\" with plotly internal behavior, or can provoke non wanted behaviors. When you draw a selection via plotly, each attributes dont used the standard fields (color, size, ...) but used the fields that are under the 2 fields \"selected\" and \"unselected\" .. and this is true only for plotly graph which accept this fields; \"selected\" and \"unselected\" are used by plotly when a \"rectangle\" selection is done a \"lasso\" selection is done if the field \"selectionpoints\" is given as a plotly data In those cases, data are divided in two groups (selected and unselected) and are drawn according to these fields. If you dont define them, plotly used internal behavior to create them (mainly reducing the tone and the opacity) the \"regular\" way (for exemple [data][marker] in scatter plot) to render graph are no more used when graph is in selection mode. A \"rectangle\" or \"lasso\" selection reset the field \"selectionpoints\" In exemple 3 and 4 we want to keep the plotly behavior for drawing and moving selection, but we also want to keep the way we draw things. So we copy the style on the \"selected\" and \"unselected\" fields because we want a global selection and not a selection which takes into account only the graph;","title":"Selection"},{"location":"wdg/selection/plot-selection/#select-and-filter-data","text":"Selection and Filter are important tools in interactive data analysis and visualisation. With Plotly JavaScript generic graph, the Chalk'it platform gives you access to selected events which contain all fields necessary in order to use selected element in the dataflow (transfer selection to another graph, filter data according to selection, ...) For those familiar with Plotly select events, \"appendix I\" will explain how xDash selection events are created.","title":"Select and Filter data"},{"location":"wdg/selection/plot-selection/#main-data-and-global-index","text":"When user wants to create a graph from a selection of another graph, or to transfer the selection from one graph to another (or from one graph to a script), there is a logic of a main shared data. This could be the result of a CSV import, a global JSON or GeoJSON. This shared data is considered and referenced as the global data in our exemples and will be present in the dataNode [data]. Each global shared data is indexed (In the CSV exemple, the index is the lane of each datum) and we will use the term \"global index\" as a generic expression to reference this main indexation.","title":"main data and global index"},{"location":"wdg/selection/plot-selection/#how-to-use-the-selection-from-a-graph-to-draw-another-one","text":"First example : selection-example-1.xprjson In this first exemple we : Plot all data in one scatter plot graph (Plotly Generic) Recover the selection from the scatter Build an histogram using only the selected data The main data is an array of datum that each contains 3 values [Alpha, Beta, Delta]. Typically obtained from a CSV import. The cross plot will be done between [alpha vs beta] and [delta] will be used to draw the histogram. The dataFlow contains 5 dataNodes and 2 associated widgets One DataNode that contains the global data. Two DataNodes are created for each Plotly Graph (data and layout) One DataNode which contains the selection One widget [plotly generic] is the scatter plot One widget [plotly generic] is the histogram The data for the Plotly histogram is dependant of the selection DataNode. The graphs and DataNodes associated (PloltlyData and PlotlyLayout) dont know each others and dont have direct relationship. In order to have a clean change in the histogram, the X axis limit and bin limits are defined via all the data.","title":"How to use the selection from a graph to draw another one"},{"location":"wdg/selection/plot-selection/#how-to-draw-a-graph-with-different-sources-of-selection","text":"Now, lets imagine that what you want to draw is defined by the addition of different incoming selections. Example 2: selection-example-2.xprjson In Exemple 2 We draw 2 scatter plots Both selection are used to draw the histogram. This exemple is similar than the last one except that : the selection datanode has now one field for each cross plot selection one dataNode is now present to process the selection [MultiSelectionProcess] The process node does the addition of each selection. The structure of the selection node has changed, there is now one field for each graph which will aggregate their selection. Each selection actuator from the cross plot now is now linked with one field of the selection node. It is relevant that the code of the process DataNode dont know the number and the origin of each incoming selections. You can so add and remove origin of selection without changing the code of the process datanode The PlotlyData datanode used for the histogram takes information from the process node. A datanode is used to collect information and create the \"global\" selection. This is not done in the datanode used for plotly data. This global selection could be used for other graphs or script without copy/paste.","title":"How to draw a graph with different sources of selection"},{"location":"wdg/selection/plot-selection/#how-to-synchronize-selection-to-have-a-single-global-selection","text":"The different selection on each graph are independant. In some case we want a \"global\" selection\" which regroup all selection and that all graph show the selected data. Example 3 selection-example-3.xprjson In this exemple we do 2 scatter plots from the same global data. As exemple 2, we use a process node to concatenate the information but on both graphs we want to see all the selected data. Plotly graphs are mainly correlated with their own selection. Trying to use the \"selectedpoints\" field present in plotly data is a bad idea. This fied is ok if the graph dont has his own selection behavior. But this field is erased when using \"rectangle\" or \"lasso\" selection. It is better to consider external selection as a complement of the possible present selection. \"appendix II\" will enter deeper in exposing the selection The additional selected items are not drawn last, so we see clearly a difference between the selection from the graph and the selection from other sources. In next exemple we propose a solution to handle this.","title":"How to synchronize selection to have a single global selection"},{"location":"wdg/selection/plot-selection/#how-to-use-the-selection-event-if-the-index-selected-are-different-from-the-data-index","text":"Example 4: selection-example-4.xprjson For the moment, in the different exemples we have assumed that the [index] given by the selection is the same that the index of the data. It means that if the data selected is \"4\" it is the same index on the global data index. But it is not always the case, for multiple reasons, the index given by the selection could be different, for exemple you need to draw only a part of the data you need to sort the data X vs Y in order to draw a line you need to sort the global data before drawing in order to control the Z order of the draw ... Each plotly trace contains a [customdata] field that can help us to resolve this problem In exemple [nom de l'exemple] we used the same But in the data for plotly DataNode we order the drawn order with all selected data at the end. it is not possible to give a drawn order to plotly (V2.16.3). The element and the trace are drawn in the order given by the user. Last element of last trace are drawn last. In the data for plotly Datanode we sort the element but we keep the change in an array called \"orderForGraph\" which will be transfer to plotly in the \"customdata\" field. This field is present in the selection of the dataflow and can be used in the selectionProcess node to obtain the equivalent index.","title":"How to use the selection event if the index selected are different from the data index"},{"location":"wdg/selection/plot-selection/#create-a-reset-selection-action","text":"Example 5: selection-example-5.xprjson in our exemple, selection is in an independant DataNode, and no more only a graphical features. In order to reset the selection, we need to clean all the DataFlow and all the graphics. In exemple 5 we create a reset selection script which is triggered by a push button. 3 significant addition in the dataNode have to be done in order to have a clean result. Reset the DataNode [Selection] via the chalkit function chalkit.setVariable . This will reset the selection and the plotly data (done in [ResetSelection] dataNode) Add the field \"selections : []\" in all layout impacted in order to remove all the visible rectangle or lasso drawn Create a relation between the resetSelection action script and the different layout to trigger the layout dataNodes.","title":"Create a reset selection action"},{"location":"wdg/selection/plot-selection/#good-practices","text":"","title":"Good Practices"},{"location":"wdg/selection/plot-selection/#create-one-datanode-for-the-layout-and-one-for-the-data","text":"If one dataNode is used to give the Data and the Layout for the widget, some unexpected graphical behavior can happen. Usually data often change according to action, but user like to keep element of visualisation (zoom, factor, element selected, ... ) When data changed, plotly will also reset the layout if they are in the same datanode, which can change your view according to what is defined in the original layout.","title":"Create one datanode for the layout and one for the data"},{"location":"wdg/selection/plot-selection/#never-use-the-same-layout-datanode-for-multiple-graphs","text":"Plotly keeps in memory each layout for its own internal use. It never makes copy. If the same layout is used for exemple for 2 scatter plots each pan/zoom/selection done on one plot ... will be passed to the other graph but not at the same time. The repercution will be done next time plotly via the dataFlow needs to check the current layout. And you dont know when it will happens (often when the widget is selected)","title":"Never use the same layout DataNode for multiple graphs."},{"location":"wdg/selection/plot-selection/#appendix-1-plotly-selection-and-chalkit-selection","text":"Structures of the plotly selection are discribe in https://plotly.com/javascript/plotlyjs-events/#event-data So plotly selection events are dependant from the kind of the original graph (2D, 3D, map, ...) Plotly selection cannot directly be transformed in JSON because it is a circular structure. Chalk'it selection event is one unified selection containing an array for each trace which contains the index of the element and the metadata if those one were present in the original trace. [curveNumber (trace number)] indexSelected : [] customdata : [] (if customdata field is present in original DataTrace) For exemple if you have 2 traces in your Plotly graph, Chalk'it selection would return : [ 0 : {Data : [1, 10, 120, 123], customData: [1, 10, 120, 123]}] [ 1 : {Data : [1, 10, 120, 123], customData: [1, 10, 120, 123]}]","title":"Appendix 1 : Plotly Selection and Chalk'it Selection"},{"location":"wdg/selection/plot-selection/#appendix-2-how-to-handle-all-selection-behaviors-from-plotly-without-creating-trouble","text":"In some situation you want to have a total control of filter/selection and the way plotly control the selection can create confusion. The behavior you need can visualy enter in \"conflict\" with plotly internal behavior, or can provoke non wanted behaviors. When you draw a selection via plotly, each attributes dont used the standard fields (color, size, ...) but used the fields that are under the 2 fields \"selected\" and \"unselected\" .. and this is true only for plotly graph which accept this fields; \"selected\" and \"unselected\" are used by plotly when a \"rectangle\" selection is done a \"lasso\" selection is done if the field \"selectionpoints\" is given as a plotly data In those cases, data are divided in two groups (selected and unselected) and are drawn according to these fields. If you dont define them, plotly used internal behavior to create them (mainly reducing the tone and the opacity) the \"regular\" way (for exemple [data][marker] in scatter plot) to render graph are no more used when graph is in selection mode. A \"rectangle\" or \"lasso\" selection reset the field \"selectionpoints\" In exemple 3 and 4 we want to keep the plotly behavior for drawing and moving selection, but we also want to keep the way we draw things. So we copy the style on the \"selected\" and \"unselected\" fields because we want a global selection and not a selection which takes into account only the graph;","title":"Appendix 2 : how to handle all selection behaviors from plotly without creating trouble"}]}